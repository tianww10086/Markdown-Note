## 10.1数组

**数组由数据类型相同的一系列元素组成** 通过声明数组告诉编译器数组中内含多少元素和这些元素的类型

**声明数组的通用形式**：

```c
type name[容量];
```

如:

```c
float candy[365];  //	内含365个float类型元素的数组
char code[12];   //内含12个char类型元素的数组
int states[50];  //内含50个int类型元素的数组
```

方括号[]表示了变量都是数组，方括号中的数字表明数组中的元素个数。

**要访问数组中的元素，通过使用数组下标数（索引）表示数组中的各元素。数组元素的编号从0开始**，所以candy[0]表示candy数组的第一个元素。candy[364]表示第365个元素，也就是最后一个元素。

#### 10.1.1 初始化数组

数组通常被用来储存程序需要的数据。例如，使用数组储存12个月的天数，这种情况下，可以在声明数组时进行初始化比较好。

```c
int month[12]={31,28,31,30,31,30,31,31,30,31,30,31};
```

如上所示，**以逗号分割的值列表（用花括号扩起来）来初始化数组**。上面把31赋给数组的首元素（month[0])，依次类推（不支持ANSI的编译器会把这种形式的初始化识别为语法错误，在数组声明前面加上关键字static可解决此问题）

我们编写一个程序，打印每个月的天数：

```c
#include<stdio.h>
#define MONTH 12
int main() {
	int month[MONTH] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
	for (int i = 0;i < MONTH;i++) {
		printf("%d月有：%d天\n", i + 1, month[i]);
	}
}
```

输出：

```c
1月有：31天
2月有：28天
3月有：31天
4月有：30天
5月有：31天
6月有：30天
7月有：31天
8月有：31天
9月有：30天
10月有：31天
11月有：30天
12月有：31天
```

该例使用了符号常量MONTH表示数组大小，这是我们推荐且常用的做法。这样我们要修改数组大小时，只需要修改#define这行代码即可，不用在程序中查找所有使用过数组大小的地方。



**使用const声明数组**

*有时需要把数组设置为只读，这样程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用const声明和初始化数组。如：*

```c
const  int month[MONTH] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
```

这样修改后，程序在运行过程中就不能修改该数组中的内容。



**如果初始化数组失败后怎么办**?下面的程序演示了这种情况

```c
#include<stdio.h>
#define SIZE 4
int main() {
	int no_data[SIZE]; //未初始化值
	int i;
	printf("%2s%14s\n", "i", "no_data[i]");
	for (i = 0;i < SIZE;i++) {
		printf("%2d%14d\n", i, no_data[i]);
	}
}
```

输出：

```c
 i    no_data[i]
 0    -858993460
 1    -858993460
 2    -858993460
 3    -858993460
```

 使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前，必须给它们赋初值。编译器使用的值是内存相应位置上的现有值，因此，在每台设备上运行该程序输出会与示例不同。



初始化列表中的项数应与数组的大小一致。如果不一致会怎么样？还是以上一个程序为例，但初始化列表中缺少两个元素

```c
#include<stdio.h>
#define SIZE 4
int main() {
	int no_data[SIZE]={123,321};
	int i;
	printf("%2s%14s", "i", "no_data[i]");
	for (i = 0;i < SIZE;i++) {
		printf("%2d%14d\n", i, no_data[i]);
	}
}
```

输出：

```c
 i    no_data[i]
 0           123
 1           321
 2             0
 3             0
```

如上所示，**当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素初始化为0**

也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其存储的都是“垃圾值”;但是如果部分初始化数组，剩余的元素就被初始化为0。



如果初始化列表的项数多于数组元素格式，编译器会将其视为错误。其实，**可以省略方括号中的数字，让编译器自动匹配数字大小和初始化列表中的项数**

```c
#include<stdio.h>
int main() {
	int month[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
	for (int index = 0;index<sizeof month / sizeof month[0];index++) {
		printf("%d月有：%d天\n", index + 1, month[index]);
	}
}
```

对于上面的程序，要注意以下两点:

- 如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小
- 注意for循环中的测试条件。 sizeof运算符给出它的运算对象的大小（以字节为单位）。所以 sizeof month是整个数组的大小，sizeof month[0]是数组中一个元素的大小。**整个数组的大小除以单个元素的大小就是数组元素的个数**。

下面是该程序的输出：

```c
1月有：31天
2月有：28天
3月有：31天
4月有：30天
5月有：31天
6月有：30天
7月有：31天
8月有：31天
9月有：30天
10月有：31天
11月有：30天
12月有：31天
```



#### 10.1.2 指定初始化器（C99）

**指定初始化器可以初始化指定的数组元素。如只初始化数组中的最后一个元素**。对于传统的C初始化语法，必须初始化最后一个元素之前所有的元素才能初始化它：

```c
int arr[6]={0,0,0,0,0,121}; //传统的语法
```

C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素：

```c
int arr[6]={[5]=212};  //把arr[5]初始化为212
```

对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0。但对于指定初始化器情况不一样



```c
#include<stdio.h>
#define MONTHS 12
int main() {
	int month[MONTHS] = { 31,28,[4] = 31,30,31,[1] = 29 };

	for (int i = 0;i < MONTHS;i++) {
		printf("%2d  %d\n", i + 1, month[i]);
	}
}
```

对于这个指定初始化器，如果你的编译器报错，请检查源文件是否为.c而并非是.cpp。或者检查编译器是否支持c99

输出：

```c
 1  31
 2  29
 3  0
 4  0
 5  31
 6  30
 7  31
 8  0
 9  0
10  0
11  0
12  0
```

指定初始化器的两个重要特性。**第一，如果指定初始化器后面有更多的值，那么后面的值将被用于初始化指定元素后面的元素**。如这个示例中：[4]=31,30,31。就是说，month[4]被初始化为31后，month[5]和month[6]分别被初始化为30和31。

**第二，如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化**。例如，初始化列表开始吧month[1]初始化为28，但是month[1]又被后面的指定初始化[1]=29初始化为29。



如果未指定元素大小会怎样？

int stuff[]={1,[6]=23};

int staff[]={1,[6]=4,9,10};

**编译器会把数组的大小设置为足够装得下初始化的值**。所以，stuff数组有7个元素，而staff数组的元素比stuff数组多两个，即9个。



#### 10.1.3 给数组元素赋值

声明数组后，可以借助数组下标给数组元素赋值

```c
/*给数组的元素赋值*/
#include<stdio.h>
#define SIZE 50
int main()
{
    int counter,evens[SIZE];
    
    for(counter=0;counter<SIZE;counter++)
        evens[counter]=2*counter;
   
    return 0;
}
```

这段代码中使用循环给数组中的元素依次赋值。

**C不允许把数组作为一个单元赋给另一个数组。除了初始化以外也不允许使用花括号列表的形式赋值**。

下面的代码演示了一些**错误**的赋值形式；

```c
/* 一些无效的数组赋值 */
#define SIZE 5
int main(){
    int oxen[SIZE] = {5,3,2,8};  /*有效初始化*/
    int yaks[SIZE]; 
    
    yaks = oxen;  //不允许
    yaks[SIZE] = oxen[SIZE];  //数组下标越界
    yaks[SIZE]= {5,3,2,8};
}

```



#### 10.1.4 指定数组的大小

在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。sizeof表达式被视为整型常量，但const值不是。另外，表达式的值必须大于0：

```c
float al[5];
float a2[5*2+1];
float a3[sizeof(int)+1]
```

C99标准之后，允许创建一种新型数组：**变长数组（VLA）**

```c
int n=5,m=6;
float arr[n]; //合法操作
float arr2[m]; //合法操作
```

*c11放弃了这一创新的举措，把VLA设定为可选，而不是语言必备的特性*。







## 10.2多维数组

C语言允许创建多维数组，这里着重讨论二维数组。



#### 10.2.1 二维数组的创建

如下面这样的声明

```c
folat rain[5][12]; //内含5个数组元素的数组，每个数组元素内含12个float类型的元素
```

**主数组**有5个元素，而每个元素是内含12个元素的数组。

可以这样理解，把二维数组看成一个表格，而float **rain\[5]**[12] ，粗体部分看为行，第二个看为列

| rain\[0][0] | rain\[0][1] | rain\[0][2] | rain\[0][3] | rain\[0][4] | rain\[0][5] | rain\[0][6] | rain\[0][7] | ···· | ···· | ···· |
| ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ---- | ---- | ---- |
| rain\[1][0] | rain\[1][1] | rain\[1][2] | rain\[1][3] | rain\[1][4] | rain\[1][5] | rain\[1][6] | rain\[1][7] | ···· | ···· | ···· |
| rain\[2][0] | rain\[2][1] | rain\[2][2] | rain\[2][3] | rain\[2][4] | rain\[2][5] | rain\[2][6] | rain\[2][7] | ···· | ···· | ···· |
| rain\[3][0] | rain\[3][1] | rain\[3][2] | rain\[3][3] | rain\[3][4] | rain\[3][5] | rain\[3][6] | rain\[3][7] | ···· | ···· | ···· |
| rain\[4][0] | rain\[4][1] | rain\[4][2] | rain\[4][3] | rain\[4][4] | rain\[4][5] | rain\[4][6] | rain\[4][7] | ···· | ···· | ···· |

在计算机内部，这样的数组是按顺序出错的，从第1个内含12个元素的数组开始，然后是第2个内含12个元素的数组，以此类推；

所以，要访问第一个元素应使用rain\[0][0], 要访问第二行，第三列的元素，则是：rain\[1][2]



#### 10.2.2 二维数组的初始化

初始化二维数组是建立在初始化一维数组的基础上。而初始化一维数组将使用数值列表初始化。

```c
type arr[5]={val1,val2,val3,val4,val5};
```

二维数组的元素是一维数组，为了初始化二维数组，要用逗号分隔n个这样的数值列表，如：

```c
float rain[5][12] = {
    // 第1行（索引0）
    {3.45, 8.12, 1.98, 6.33, 9.01, 4.76, 2.54, 7.89, 5.12, 1.23, 10.00, 2.22},
    
    // 第2行（索引1）
    {5.67, 2.34, 9.87, 4.56, 7.83, 3.21, 6.54, 1.09, 8.76, 3.45, 7.89, 5.43},
    
    // 第3行（索引2）
    {1.11, 9.99, 4.44, 8.88, 2.75, 6.66, 3.33, 5.55, 7.77, 10.00, 1.50, 9.50},
    
    // 第4行（索引3）
    {2.22, 4.44, 6.66, 8.88, 1.11, 3.33, 5.55, 7.77, 9.99, 2.50, 5.00, 7.50},
    
    // 第5行（索引4）
    {10.00, 8.25, 6.75, 4.50, 2.25, 9.75, 7.25, 5.00, 3.75, 1.25, 8.50, 6.25}
};
```

这个初始化使用了5个数值列表，每个列表都用花括号括起来。第一个列表的数据用于初始化数组的第一行，第2个列表的数据用于初始化数组的第2行。以此类推





#### 10.2.3 其他多维数组

前面讨论的二维数组相关内容也适用于三维数组或更多维的数组。可以这样声明一个三位数组：

```c
int box[10][20][30];
```

可以把一维数组想象成一行数据，把二维数组想象成数据表，把三位数组想象成一叠数据表。例如，把上面声明的三维数组box想象成由10个二维数组（每个二维数组都是20行30列）堆叠起来

还有一种理解box的方法是，把box看作数组的数组，也就是说，box内含10个元素，每个元素是内含20个元素的数组，这20个数组元素中的每个元素是内含30个元素的数组。可以简单地根据所需的下标值去理解数组。

通常，处理三维数组要使用3重嵌套循环，处理四维数组要使用4重嵌套循。对于其他多维数组，依次类推。在后面的程序示例中，我们只使用二维数组



#### 10.2.4 使用循环给数组赋值

对于数组存储所需要的值，复合某种规律的，或需要指定输入的，我们使用for循环来处理

一维数组:

```c
#include<stdio.h>
int main() {
	int arr[10];
    //输入数组
	for (int i = 0;i < 10;i++) {
		printf("请输入数组的第%d个值:", i + 1);
		scanf("%d",&arr[i]);
	}
    
    //输出数组
    for (int i = 0;i < 10;i++) {
		printf("请数组的第%d个值\n:",arr[i]);
		
	}
}
```



二维数组：

```c
#include<stdio.h>
int main() {
	int arr[5][10];
	for (int i = 0;i <5;i++) {
		for (int j = 0;j < 10;j++){
			printf("请输入数组的第%d行，第%d列的值:",i + 1,j+1);
			scanf_s("%d", &arr[i][j]);
		}
	}
}
```





## 10.3 指针和数组

指针和数组有非常紧密的关系，使用指针能有效的处理数组。**实际上使用数组就是在变相的使用指针**

首先，**数组名就是数组首元素的地址**。也就是说，如果flizny是一个数组，下面的语句成立：

```c
flizny == &flizny[0];  //数组名是该数组首元素的地址
```

flizny和&flizny[0]都是表示数组首地址的内存地址（&是地址运算符）。**两者都是常量**，

下面我们演示对指针进行某些操作，会对地址有什么影响

```c
#include<stdio.h>
#define SIZE 4
int main() {
	short dates[SIZE];  //声明了一个能存储SIZE个short类型的值的数组
	short* pti;  //声明一个能指向short类型变量的指针
	short index;
	double bills[SIZE]; //数组
	double* ptf; //能指向double类型变量的指针

	pti = dates;  //指针指向了dates数组的首地址
	ptf = bills;//指针指向了bills数组的首地址

	printf("%23s %15s\n", "short", "double");
	for (index = 0;index < SIZE;index++)
		printf("指针+%d: %10p %10p:\n", index, pti + index, ptf + index);
	return 0;
}
```

示例输出：

```c
                  short          double
指针+0: 00000039842FF848 00000039842FF8A8
指针+1: 00000039842FF84A 00000039842FF8B0
指针+2: 00000039842FF84C 00000039842FF8B8
指针+3: 00000039842FF84E 00000039842FF8C0
```

地址按字节编制，short类型占用2字节，double占用8字节

**在C中，指针+1指的是增加一个存储单元，对数组而言，这意味着把加1后的地址是下一个元素的地址**。这就是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节。



现在可以更清楚地定义指向int的指针、指向float的指针，以及指向其他数据对象的指针。

- 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机都是按字节编址。
- 在指针面前使用*运算符就可以得到该指针所指向对象的值
- 指针加1，指针的值递增它所指向类型的大小（以字节为单位）



下面的等式体现了C语言的**灵活性**：

```c
dates +2  ==&dates[2];   //相同的地址
*（dates+2） == dates[2];  //相同的值
```

以上关系表明了数组和指针的关系十分密切，**可以使用指针标识数组的元素和获得元素的值**。

从本质上看，同一个对象有两种表示法。实际上，C语言标准在描述数组表示法时确实借助了指针。也就是说，定义ar[n]的意思是\*(ar+n)。可以认为\*(ar+n)的意思是“到内存ar位置，然后移动n个单元，检索存储在那的值”

顺带一提，不要混淆\*(dates+2)和\*dates+2。间接运算符(\*)的优先级高于+;

```c
*（dates+2） //dates第3个元素的值
*dates+2;  //dates第1个元素的值+2
```

明白数组和指针的关系，便可在编写程序时适时的使用数组表示法或指针表示法。

```c
#include<stdio.h>
#define MONTH 12
int main() {
	int month[MONTH] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
	for (int i = 0;i < MONTH;i++) {
		printf("%d月有：%d天\n", i + 1, *(month+i));
	}
}
```



## 10.4 函数、数组和指针

要编写一个处理数组的函数，该函数返回数组中所有元素之和。应该如何调用函数？记住，数组名是该数组首元素的地址，所以实际参数是一个存储int类型值的地址，应该把它赋给一个指针形式参数，即该形参是一个指向int的指针：

```c
int sum(int *ar); //对应的函数原型
```

该函数原型从参数获取了该数组首元素的地址这个信息，但该参数并未包含数组元素个数的信息。我们有两种方法让函数获得这一信息。

第一种方法是，在函数代码中写上固定的数组大小：

```c
int sum(int* arr) {
	int sum = 0;
	for (int i = 0;i < 10;i++)
		sum += *(arr + i);  //或使用数组sum+=arr[i]; 效果一直
	return sum;
}
```

该函数定义有限制，只能计算10个int类型的元素

第二种方法是把数组大小作为第2个参数：

```c
int sum(int* arr,int n) {
	int sum = 0;
	for (int i = 0;i < n;i++)
		sum += *(arr + i);  //或使用数组sum+=arr[i]; 效果一样
	return sum;
}
```



注意：**对于函数的形参，int *ar 形式和int ar[]形式都表ar是一个指向int的指针。第二种形式（int ar[])提醒读者指针ar指向的不仅仅是一个int类型值，还是一个int类型数组的元素**。

因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针，只有在这种情况下，C才会把int ar[]和int *ar解释成一样的。

由于函数原型可以省略参数名，所以下面4种原型是等价的：

```c
int sum(int *ar,int n);
int sum(int *,int);
int sum(int ar[],int n);
int sum(int [],int);
```

但是，在函数定义中不能省略参数名。



下面我们通过一个程序来演示上述特性

```c
//数组元素之和
#include<stdio.h>
#define SIZE 10
int sum(int arr[], int n);
int main() {
	int marbles[SIZE] = { 20,10,5,39,4,16,19,26,31,20 };
	int answer;
	answer = sum(marbles, SIZE);
	printf("该数组元素之和为：%d\n", answer);
	printf("marbles的大小为%zd\n", sizeof marbles);
}

int sum(int arr[], int n) {
	int total = 0;
	for (int i = 0;i < n;i++)
		total += arr[i];
	printf("arr的大小为%zd\n", sizeof arr);
	return total;
}
```

该示例输出：

```c
arr的大小为8
该数组元素之和为：190
marbles的大小为40
```

注意，marbles的大小是40字节。这没问题，因为marbles内含10个int类型的值，每个值占4字节，所以整个marbles的大小是40字节。

但ar才8字节。这是因为ar并不是数组本身，它是指向一个marbles数组首元素的指针。我们系统中用8字节存储地址，所以指针变量的大小是8字节。





#### 10.4.1 使用指针形参

**函数处理数组必须知道何时开始，何时结束**。上一个例子用一个整型参数表明待处理数组元素的个数，这并不是唯一的办法。

**还有一种方法是传递两个指针，第1个指针指明数组的开始处（与前面用法相同），第2个指针指明数组的结束处**。下面的程序演示了这种方法

```c
//数组元素之和
#include<stdio.h>
#define SIZE 10 
int sum(int * start, int *end);//需要传入两个指针参数
int main() {
	int marbles[SIZE] = { 20,10,5,39,4,16,19,26,31,20 };
	int answer;
	answer = sum(marbles,marbles+SIZE); //一个指向数组首元素，一个指向数组尾元素
	printf("该数组元素之和为：%d\n", answer);
	
	return 0;
}

/*使用指针算法 */
int sum(int* start, int* end){
	int total = 0;
	while (start < end) {
		total += *start; //把数组元素的值加起来
		start++;  //让指针指向下一个元素
	}
	return total;
}
```

示例输出：

```c
该数组元素之和为：190
```

指针start指向marbles数组的首元素，所以赋值表达式total +=*start把首元素加给total。然后表达式start++递增指针变量start，使其指向数组的下一个元素。因为start是指向int的指针，start递增1相当于其值递增int类型的大小。

注意while循环的测试条件是一个不相等的关系，所以循环最后处理的一个元素end所指向位置的前一个元素。这意味着end指向的位置实际上在数组最后一个元素前面。**C保证在给数组分配空间时，指向数组后面第一个位置的指针扔是有效的指针**。

因为下标从0开始，所以marbles+SIZE指向数组末尾的下一个位置。如果end指向数组的最后一个元素而不是数组末尾的下一个位置，必须使用下面的代码：

```c
answer = sum(marbles,marbles+SIZE-1);
```

顺带一提，**虽然C保证了marbles +SIZE有效，但是对marbles\[SIZE](即存储在该位置上的值)未做任何保证，所以程序不能访问该位置**。



#### 10.4.2 指针表示法和数组表示法

从以上分析可知，处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，是选择数组表示法还是指针表示法。使用数组表示法，让函数是处理数组的这一意图更加明显。

数组表示法：

```c
sum(int start[],int end[]);
```

指针表示法：

```c
int sum(int* start, int* end)
```

而指针表示法（尤其和递增运算符一起使用时）更接近机器语言，编译器在编译时能生成效率更高的代码。然后，**程序员的主要任务是确保代码正确、逻辑清晰**；









## 10.5 指针操作

​	C提供了一些基本的指针操作。下面的程序演示了8种不同的操作。为了显示每种操作的结果，该程序打印了指针的值、储存在指针指向地址上的值，以及指针自己的地址

```c
//指针操作
#include<stdio.h>
int main() {
	int urn[5] = { 100,200,300,400,500 };

	int* ptr1, * ptr2, * ptr3;

	ptr1 = urn; //ptr1指向urn数组
	ptr2 = &urn[2];  //ptr2指向urn[2]元素

	//解引用指针，以及获得指针的地址；
	printf("指针的值          解引用指针          指针的地址:\n");
	printf("ptr1=%p   *ptr1=%d   &ptr1=%p\n", ptr1, *ptr1, &ptr1);
	
	//指针加法
	ptr3 = ptr1 + 4; //即ptr3指向urn数组最后一个元素
	printf("对指针进行整型加法：\n");
	printf("ptr1+4=%p  *(ptr1+4)=%d\n", ptr1 + 4, *(ptr1 + 4));
	ptr1++;   //指针指向urn第二个元素
	printf("ptr1递加之后的值：\n");
	printf("ptr1=%p   *ptr1=%d   &ptr1=%p\n", ptr1, *ptr1, &ptr1);
	ptr2--;  //ptr2指向指针第2个元素
	printf("ptr2递减之后的值：\n");
	printf("ptr2=%p   *ptr2=%d   &ptr2=%p\n", ptr2, *ptr2, &ptr2);
	//恢复原值
	ptr1--;
	ptr2++;
	printf("指针重置为原始值\n");
	printf("ptr1=%p,ptr2=%p\n", ptr1, ptr2);
	//一个指针减去另一个指针
	printf("从一个指针中减去另一个指针：\n");
	printf("ptr2 = %p, ptr1 = %p, ptr2-ptr1 = %td\n", ptr2, ptr1, ptr2 - ptr1);
	//一个指针减去一个整数
	printf("从一个指针中减去一个整数：\n");
	printf("ptr3=%p ptr3-2=%p\n", ptr3, ptr3 - 2);
}
```

示例输出

```c
指针的值          解引用指针          指针的地址:
ptr1=00000023A60FFA48   *ptr1=100   &ptr1=00000023A60FFA78
对指针进行整型加法：
ptr1+4=00000023A60FFA58  *(ptr1+4)=500
ptr1递加之后的值：
ptr1=00000023A60FFA4C   *ptr1=200   &ptr1=00000023A60FFA78
ptr2递减之后的值：
ptr2=00000023A60FFA4C   *ptr2=200   &ptr2=00000023A60FFA98
指针重置为原始值
ptr1=00000023A60FFA48,ptr2=00000023A60FFA50
从一个指针中减去另一个指针：
ptr2 = 00000023A60FFA50, ptr1 = 00000023A60FFA48, ptr2-ptr1 = 2
从一个指针中减去一个整数
ptr3=00000023A60FFA58 ptr3-2=00000023A60FFA50
```



#### 10.5.1指针基本操作

下面分别描述了指针变量的基本操作

1. **赋值**：可以把地址赋给指针。例如，用数组名、带地址运算符（&）的变量名，另一个指针进行赋值。注意，**地址应和指针类型兼容，也就是，不能把double类型的地址赋给指向int的指针**
2. **解引用**：\*运算符给出指针指向地址上存储的值。因此，\*ptr1的初值是100，该值存储在编号为*000000023A60FFA48*的地址上。
3. **取址**：和所有变量一样，指针变量也有自己的地址和值。对于指针而言，&运算符给出指针本身的地址。该存储单元存储的是地址。
4. **指针与整数相加**：可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。因此ptr1+4与&urn[4]等价。**如果相加的结果超出了初始指针指向的数组范围，计算结是则是未定义的，除非正好超过数组末尾第以个位置，C保证该指针有效**。
5. **递增指针**：递增指向数组元素的指针可与让该指针移动至数组的下一个元素。因此,ptr1++相当于把ptr1的值加上4（int为4字节），ptr1指向urn[1]；
6. **指针减去一个整数**：可以使用-运算符从一个指针中减去一个整数。指针必须 是第1个运算对象，整数是第2个运算对象。该整数将乘以指针指向类型的大小，然后用初始地址减去乘积。所以ptr3-2 与urn[2]等价，因为ptr3指向的是&arn[4]。**如果相减的结果超出了初始指针指向的数组范围，计算结是则是未定义的，除非正好超过数组末尾第以个位置，C保证该指针有效**。
7. **递减指针**：与递加指针类似，递减指针会使该指移动至数组的上一个元素。
8. **指针求差**：可以计算两个指针的差值。**通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离**。差值的单位与数组类型的单位相同。如ptr2-ptr1得2，意思是这两个指针所指向的两个元素相隔两个int，而不是2字节。只要保证两个指针都指向相同的数组。C都能保证相减运算有效。
9. **比较**：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。



## 10.6 保护数组中的数据

编写一个函数时，通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。对于数组别无选择，必须传递指针。这样做效率更高。

传递地址会导致一些问题，程序可能会意外修原始数据，有时我们并不需要修改原始数据：

```c
int sum(int ar[], int n) { //错误的代码
	int total = 0;
	for (int i = 0;i < n;i++) {
		total += ar[i]++; //错误递增了每个元素的值
	}
	return total;
}
```



#### 10.6.1 对形式参数使用const

在函数原型和函数定义中声明形式参数使用关键字const：

```c
int sum( const int ar[], int n);//函数原型
```

```c
int sum(const int ar[], int n) { //函数定义
	int total = 0;
	for (int i = 0;i < n;i++) 
		total += ar[i];
	
	return total;
}
```

**const的作用是告诉编译器，该函数不能修改ar指向的数组中的内容。如果函数中不小心使类似ar[i]++的表达式，编译器会捕获这个错误，并生成一条错误信息。**

**使用const并不要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改**。如果编写的函数不用修改数组，那么在声明数组形参时最好使用const。

下面的程序中，一个函数显示数组的内容，另一个函数给数组每个元素都乘以一个定值。第1个函数不用修改数组，所以在声明数组形参时使用了cosnt；而第2个函数需要修改数组元素的值，所以不用const。

```c
#include<stdio.h>
#define SIZE 5
void show_array(const double ar[], int n);
void mult_array(double ar[], int n,double mult);
int main() {
	double dip[SIZE] = { 20.0,17.66,8.2,15.3,22.22 };
	printf("原始 dip 数组：\n");
	show_array(dip, SIZE);
	mult_array(dip, SIZE, 2.5);
	printf("修改过后的dip数组：\n");
	show_array(dip, SIZE);
}

/*显示数组的内容*/
void show_array(const double ar[], int n) {
	for (int i = 0;i < n;i++) {
		printf("%8.3lf", ar[i]);
	}
	putchar('\n');
}

/*把数组的每个元素都乘以相同的值*/
void mult_array(double ar[], int n ,double mult) {
	for (int i = 0;i < n;i++)
		ar[i] *= mult;

}
```

示例输出：

````
原始 dip 数组：
  20.000  17.660   8.200  15.300  22.220
修改过后的dip数组：
  50.000  44.150  20.500  38.250  55.550
````



#### 10.6.2 const的其他内容

const的用法非常灵活，可以创建const数组、const指针和指向const的指针

**1 const数组**

```c
const int days[12]={31,28,31,30,.....};
```

如果程序稍后试图修改数组元素的值，编译器将生成一个错误消息：

````c
days[9]=44;  /*编译错误*/
````



**2 const指针**

为指针变量添加const限定符后，指针不能用于改变值。

```c
double rates[3]={12.2,15.6,18.5};
const double *pd = rates; //pd指向数组的首元素
```

当我们后续试图通过指针修改值时，编译器会生成错误消息

```c
*pd = 28.6; //不允许
pd[2]=22.2;  //不允许
rates[0]=99.9; //允许，因为rates未被const限定
```

无论是指针表示法还是数组表示法，都不允许使用pd修改它所指向数据的值。另外，可以让pd指向别处：

```c
pd++; /*让pd指向rates[1] -- 没问题*/
```

指向const的指针通常用于函数形参中，表明该函数不会使用指针改变数据



**3.关于指针赋值和const需要注意的规则**

3.1把const数据或非const数据的地址初始化为指向const指针或为其赋值是合法的：

```c
double rates[5]={12.2,15.6,18.5,183.11,23.5};
const double locked[4]={0.08,0.075,0.0725};
const double *pc = rates; //有效
pc = locked;  //有效
pc = &rates[3];  //有效
```

然而，**只能把非const数据的地址赋给普通指针**：

```c
double rates[5]={12.2,15.6,18.5,183.11,23.5};
const double locked[4]={0.08,0.075,0.0725};
double * pnc = rates;  //有效
pnc = locked; //无效；
```

换句话说，**不能使普通指针指向有const常量**。



3.2 可以声明并初始化不能指向别处的指针，关键是const的位置：

```c
double rates[5]={12.2,15.6,18.5,183.11,23.5};
double *const pc = rates;
pc = &rates[2]; //不允许；
*pc = 92.99; //没问题
```

可以用这种指针修改它所指向的值





## 10.7 指针和多维数组

假设有下面的声明：

```c
int zippo[4][2]; /**/
```

数组名zippo是该数组首元素的地址。zippo的首元素是一个内含两个int值的数组，所以zippo是这个内含两个int值的数组的地址。

我们从指针的属性进行分析：

**1** 因为zippo是数组首元素的地址，所以zippo的地址和&zippo[0]的值相同。而zippo[0]本身是一个内含两个整数的数组，所以zippo[0]的值和它首元素（一个整数）的地址即（&zippo\[0][0])相同。简而言之，zippo[0]是一个占用一个int大小对象的地址，而zippo是占用两个int大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一地址，所以zippo和zippp[0]的值相同

**2** 给指针或地址加1，其值会增加对应类型大小的数值。在这方面，zippo和zippo[0]不同，因为zippo指向的对象占用了两个int大小，而zippo[0]指向的对象只占用一个int大小。

**3** 对于该例，解引用\*(zippo[0])表示存储在zippo\[0][0]上的值，与此类似\*zippo代表该数组首元素（zippo[0] )的值，但是zippo[0]本身是一个int类型值的地址。所以\*zippo == &zippo\[0][0] 。而\*\*zippo与\*&zippo\[0][0]等价。这相当于zippo\[0][0]。**简而言之,zippo是地址的地址，必须解引用两次才能获得原值。地址的地址或指针的指针就是双重间接的例子**。

显然，增加数组维数会增加指针的复杂度。

```c
#include<stdio.h>

int main()
{
	int zippo[4][2] =
	{
		{2,4},
		{6,8},
		{1,3},
		{5,7}
	};

	printf("   zippo = %p,   zippo+1=%p\n", zippo, zippo + 1);
	printf("zippo[0]=%p, zippo[0]+1=%p\n", zippo[0], zippo[0] + 1);
	//zippo == zippo[0] == &zippo[0][0]
 	printf(" *zippo = %p, *zippo+1=%p\n", *zippo, *zippo + 1);
 	printf(" &zippo[0][0] = %p, &zippo[0][0]+1=%p\n", &zippo[0][0], &zippo[0][0]);
	printf("zippo[0][0]=%d\n", zippo[0][0]);
	//*zippo[0] = zippo[0][0]==**zippo;
	printf(" *zippo[0] =%d\n", *zippo[0]);
	printf("    **zippo = %d\n", **zippo);
	printf("     zippo[2][1] = %d\n", zippo[2][1]);
	printf("*(*(zippo+2)+1)=%d\n", *(*(zippo + 2) + 1));
}
```

示例输出：

```c
   zippo = 000000FDAE1EF6B8,   zippo+1=000000FDAE1EF6C0
zippo[0]=000000FDAE1EF6B8, zippo[0]+1=000000FDAE1EF6BC
 *zippo = 000000FDAE1EF6B8, *zippo+1=000000FDAE1EF6BC
 &zippo[0][0] = 000000FDAE1EF6B8, &zippo[0][0]+1=000000FDAE1EF6B8
zippo[0][0]=2
 *zippo[0] =2
    **zippo = 2
     zippo[2][1] = 3
*(*(zippo+2)+1)=3
```

特别注意，与zippo\[2][1]等价的指针表示法是\*(\*(zippo+2)+1)。下面理解该表达式的思路：

```c
zippo      <-二维数组首元素的地址（每个元素都是内含两个int类型元素的一维数组）
zippo+2    <- 二维数组的第3个元素（即一维数组）的地址
*(zippo+2)   <-二维数组的第3个元素（即一维数组）的首元素（一个int类型的值）地址
*(zippo+2) +1    <-二维数组的第3个元素（即一维数组）的第2个元素（也是一个int类型的值）地址
*(*(zippo+2) +1  )   <-二维数组的第三个一维数组元素的第2个int类型元素的值，即数组的第3行第2列的值（zippo[2][1]）
```





#### 10.7.1 指向多维数组的指针

如何声明一个指针变量pz指向一个二维数组（如，zippo)？把指针声明为指向int的类型还不够，指向int只能与一维数组匹配。如果想指向zippo。zippo是它首元素的地址，该元素是一个内含两个int类型值的一维数组。因此，pz必须指向一个内含两个int类型的数组。

```c
int (*pz)[2];  //pz指向一个内含两个int类型值的数组
```

为什么要加括号，因为[]优先级高于*。

```c
int *pax[2];  //pax是一个内含两个指针元素的数组，每个元素都指向int的指针
```



#### 10.7.2 指针的兼容性

指针之间的赋值比数据类型之间的赋值要严格，例如，不用类型转换就可以把int类型的值赋给double类型的变量。但是两个类型指针不能这样做

```c
int n=5;
double x=10;
int *p1=&n;
double *pd = &x;
x=n;  //隐私类型转换
pd = p1   //编译时错误
```





#### 10.7.3 函数和多维数组

如果要编写处理二维数组的函数。在函数体中，通常使用数组表示法进行相关操作。

```c
void somefunction(int pt[][4]);
```

这表明了pt是一个指向了包含四个元素的数组的指针。后续使用只需传入地址。

```c
#include<stdio.h>
#define ROWS 3  //行数
#define COLS 4  //列数
//函数都一样，只不过换个写法
void sum_rows(int ar[][COLS], int rows);
int sum2d(int (*ar)[COLS], int rows); //另一种用法
int main()
{
	int junk[ROWS][COLS] =
	{
		{2,4,6,8},
		{3,5,7,9},
		{12,10,8,6}
	};
	sum_rows(junk, ROWS);

}

void sum_rows(int ar[][COLS], int rows)
{
	int r, c, tot=0;
	for(r = 0; r < rows;r++)
	{
		tot = 0;
		for (c = 0;c < COLS;c++)
			tot += ar[r][c];
		printf("row %d: sum = %d\n", r, tot);
	}

}

int sum2d(int (*ar)[COLS], int rows) {
	int r, c, tot = 0;
	for (r = 0; r < rows;r++)
	{
		tot = 0;
		for (c = 0;c < COLS;c++)
			tot += ar[r][c];
		printf("row %d: sum = %d\n", r, tot);
	}
}
```



## 10.8变长数组（VAL）

为什么只把数组的行数作为函数的形参，而列数却内置在函数体内：

```c
int sum_rows(int ar[][COLS], int rows)
{
	int r, c, tot=0;
	for(r = 0; r < rows;r++)
	{
		for (c = 0;c < COLS;c++)
			tot += ar[r][c];
		printf("row %d: sum = %d\n", r, tot);
	}
	return tot;
}
```

假设声明了下列数组：

```c
int array1[5][4];
int array2[100][4];
int array3[2][4];
```

可以分别用 sum_rows函数计算这些数组元素之和

```c
tot = sum_rows(array1,5);
tot = sum_rows(array2,100);
tot = sum_rows(array3,2);
```

之所以函数能处理他们，是因为这些数组的列数固定为4。所以，为了创建一个能处理任意大小的函数。C99新增了变长数组，允许使用变量表示数组的维度：

```c
int quar=4;
int reg=5;
double sales[quar][reg]; //一个变长数组
```

变长数组必须是自动存储类别。且C11中变长数组作为一个可选特性，而不是必须强制实现的特性。





## 10.9 复合字面量

复合字面量类似于数组初始化列表，前面是用括号圈起来的类型名：

```c
(int [2]){10,20};  //复合字面量
```

复合字面量的大小也可以省略，编译器会自动计算元素个数：

```c
(int []){50,20,90};
```

因为复合字面量是匿名的，所以不能先创建再使用，必须在创建的同时使用它。使用指针记录地址就是一种方法：

```c
int *pti;
pti = (int []){20,34,65};
```

或作为函数参数传递

```c
sum(const int [],int n);
-----
int total;
total = sum((int []){12,36,78,90},6);
```





