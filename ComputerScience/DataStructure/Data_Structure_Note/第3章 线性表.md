## 3.1 线性表的定义

==线性表（List）：零个或多个数据元素的有限数列==

首先，它是一个序列，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继。其他元素都有且只有一个前驱和后继。

**线性表元素的个数n(n>=0)定义为线性表的长度，当n=0时，称为空表**。

在较复杂的线性表中，一个数据元素可以由若干个数据项组成

| 学号 | 姓名 | 性别 | 出生年月 | 家庭地址         |
| ---- | ---- | ---- | -------- | ---------------- |
| 1    | 张三 | 男   | 1995.3   | 东街西巷1号203室 |
| 2    | 李四 | 男   | 1994.6   | 北路3室          |
| .... | ...  | .... | ....     | ....             |
| ...  | ...  | ...  | ...      | ...              |



## 3.2线性表的抽象数据类型

对于一个线性表来说，或者大部分数据结构来说，**增删改查都是基本操作**。

```c
ADT 线性表（List）
Data
	线性表的数据对象集合为{a_1,a_2,.....,a_n},每个元素的类型均为DataType。其中，除了第一个元素a_1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素a_n外，每一个元素有且只有一个直接后继元素，数据元素之间的关系是一对一的关系
Operation
	IniList(*L):初始化操作，建立一个空的线性表L。
	ListEmpty(L):若线性表为空，返回true，反之返回false。
	ClearList(*L):将线性表清空。
	GetElem(L,i,*e):将线性表L中的第i个位置元素值返回给e。
	LocateElem(L,e):在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素表中序号表示成功；否则，返回0表示失败。
	ListInsert(*L,i,e):在线性表L中的第i个位置插入新元素e。
	ListDelete(*L,i,*e):删除线性表L中的第i个位置元素，并用e返回其值。
	ListLength(L):返回线性表L的元素个数
endADT
```



#### 3.2.1 测试程序结构

```c
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
//默认带头节点实现链表
#define OK 1
#define ERROR 0
#define MAXSIZE 5
#define FALSE 0
#define TRUE 1
typedef int Element; //顺序表的元素类型
typedef int Status; //函数的返回状态值
void showMenu(){
	printf("-----循环链表操作-----\n");
	printf("1.初始化\t 2.该表是否为空\n");
	printf("3.清空该表\t 4.获取元素\n");
	printf("5.查找元素\t 6.插入元素\n");
	printf("7.删除元素\t 8.查询表元素个数\n");
	printf("9.显示所有表元素\n10.头插法创建整表\n");
	printf("11.尾插发创建正表\n12.销毁该表\n");
	
}
int main(){
	
	int flag;
	showMenu();
	printf("请选择你要做的操作：(按0结束)\n");
	scanf("%d",&flag);
	while(flag){
		switch (flag) {
		case 1:{
			break;
		}
			
		case 2:{
		
			break;
		}
		case 3:{
			
				break;
		}
		case 4:{
				break;
				
		}
		case 5:{
				break;
		}
		case 6:{
			break;
				
		}
		case 7:{
			break;
		}
		case 8:{
			break;
		}
		default:{
			printf("无效操作\n");
		}
		}
		showMenu();
		printf("请选择你要做的操作：(按0结束)\n");
		scanf("%d",&flag);
	}
}


```







## 3.3 线性表的顺序存储结构

**线性表的顺序存储结构，指的是用一段连续地址的存储单元依次存储线性表的数据元素**。在C语言中，可以用一维数组来实现顺序存储结构。

```c
#define MAXSIZE 30
typedef int ElemType; //数据元素
typedef struct{
    ElemType date[MAXSIZE];
    int length;
}SqList;
```

顺序存储结构需要三个属性：

- 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。
- 线性表的最大存储容量：数组长度MAXSIZE。
- 线性表的当前长度：length。



#### 3.3.1 线性表长度

  **线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的**。而数组的长度从分配存储空间之后就没变过。



## 3.4 顺序表的操作

下面将讲解顺序表每个操作的代码



#### 3.4.1 顺序表基本操作

基本操作包括：**初始化表，检查表是否为空，清空表**

```c
#include<stdio.h>
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
//顺序表的结构代码
#define MAXSIZE 30
typedef int ElemType;
typedef int Status;  //函数的返回状态值

//表结构
typedef struct{
	ElemType  data[MAXSIZE];
	int length;
}SqList;

//初始化顺序表，建立一个空的线性表
int IniList(SqList *L){
	L->length=0;
	return OK;
}

//检查表是否为空
int ListEmpty(SqList L){
	if(L.length==0)
		return TRUE;
	else
		return FALSE;
}

//清空表操作
int ClearList(SqList *L){
	L->length=0;
	return OK;
}
/* 初始条件：顺序线性表L已存在。操作结果：返回L中数据元素个数 */
int ListLength(SqList L)
{
	return L.length;
}
```

表的长度可以通过结构SqList中的length获取



#### 3.4.2 获取元素操作

​	该程序唯一的注意点是前提条件，表中不能为零，且下标i值不能超过合理范围，不能小于0或不能大于表长度。就程序而言，只要i值在数组下标范围内，就把数组的i-1下标的值返回即可。

```c
//查找表中第i个元素
Status GetElem(SqList L,int i, ElemType *e){
	//检查错误条件，只有满足其一，返回错误值
	if(L.length == 0 || i<1|| i>L.length)
		return ERROR;
	*e=L.data[i-1];
	return OK;
}
```

在C语言中，**若需通过指针参数返回值，必须解引用（`*e = value`）**。直接赋值指针（`e = address`）仅影响函数内的局部副本。



#### 3.4.3 查找操作

LocateElem(L,e):在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素表中序号表示成功；否则，返回0表示失败。

```java
//通过元素查找（简略版本）
int LocateElem(SqList L, ElemType e){
	//如果未进入循环着说明L.length的长度小于或等于i
	for(int i=0;i<L.length;i++){
		if(L.data[i]==e){
			return i+1; //返回序号
		}
	}
	return 0;
}
```



#### 3.4.4 插入操作

插入算法的思路：

1. 如果插入位置不合理，抛出异常；
2. 如果线性表的长度大于等于数字长度，则抛出异常或动态增加容量；
3. 从最后一个元素开始向前遍历到第i个位置，分别将它们向后移动一个位置；
4. 将要插入元素填入位置i处；
5. 表长+1；

代码如下；
```c
//初始条件：顺序线性表已经存在，1<=i<=ListLength。
//操作结果：在L中第i个位置之前插入新的数据元素e,L的长度加1
Status ListInsert(SqList *L,int i,ElemType e){
	
	if(L->length == MAXSIZE) //顺序表已经满
		return ERROR; 
	
	if(i<1 || i>L->length+1) //当i比第一位小或者比最后一位还要大时
		return ERROR;
	//通过判断代表i值在 1~ Length+1之间
	
	//若插入的数据不在表
	if(i<=L->length){
		//k：表尾下标（length-1);
		//i:插入下标（实际位置-1)；
		//给要插入的位置腾出来
		for(int k=L->length-1;k>=i-1;k--){
			//把每个元素后移一格，遍历到i值。
			L->data[k+1] =L->data[k];
		}
	}
	L->data[i-1] = e;
	L->length++;
	return OK;
}
```

**情况分析1:**

设MAXSIZE为100；插入位置为1，表长度为0。通过1、2if判断，且插入的数据位置在表尾。跳过第3条if语句，直接插入。

**情况分析2**：

设MAXSIZE为100，插入位置为50。表length长度为60。通过1、2、3判断，并且执行元素后移操作，将依次执行：

```java
L->data[60]=L->data[59]; //k=(60-1)59,k>=(49)50-1;  //现在L->data[60]为表尾
L->data[59]=L->data[58]; //k=58;k>=(49)50-1; 
L->data[58]=L->data[57]; //k=57;k>=(49)50-1;
L->data[57]=L->data[56]; //k=56;k>=(49)50-1; 
L->data[56]=L->data[55]; //k=55;k>=(49)50-1;
L->data[55]=L->data[54]; //k=54;k>=(49)50-1;
L->data[54]=L->data[53]; //k=53;k>=(49)50-1; 
L->data[53]=L->data[52]; //k=52;k>=(49)50-1; 
L->data[52]=L->data[51]; //k=51;k>=(49)50-1; 
L->data[51]=L->data[50]; //k=50;k>=(49)50-1;
L->data[50]=L->data[49]; //k=49;k>=(49)50-1;
k=48 ; //k=48;k>=(49)50-1; 不满足条件
```

这个for循环一共执行了10次，最后一次，将L->data[49]的位置让了出来，即第50个元素。现在就可以直接赋值，并且表长+1；

```java
L->data[50-1] = e;
L->length++;
```

**情况分析3**：

设MAXSIZE为100，插入位置为第100。表长为100。无法通过第1个判断。返回错误值

​	可以总结出这样一条规律：

​	**向一个长度为n的顺序表第$i(0<=i<=n)$个元素之前插入一个元素时，需向后移动==$n-i+1$==个元素。**为什么范围包括n？数组的下标范围不是从$0到n-1$吗。这是因为，插入操作允许在最后一个元素的后面插入，这等同于添加操作。当前前提是当前数组并没有满。所以插入操作会先检查数组当前的元素个数是否等于数组最大长度：

```c
	if(L->length == MAXSIZE) //顺序表已经满
		return ERROR; 
```





#### 3.4.5 删除操作

删除算法的思路

1. 如果删除的位置不合理，抛出异常；
2. 取出删除元素；
3. 从删除元素位置开始遍历到最后一个元素位置，分别将他们都向前移动一个位置；
4. 表长减1；

代码如下：

```java
//初始条件，表L存在，1<=i<=ListLength(L);
//操作结果：删除L的第i个元素，并用e返回其值，L的长度减1
Status ListDelete(SqList *L,int i,ElemType *e){
	//空表返回错误
	if(L->length == 0)
		return ERROR;
	
	//错误值返回错误： i<1 || i>Length
	if(i<1 || i>L->length)
		return ERROR;
	
	//返回其值
	*e = L->data[i-1];
	
	//如果删除的不是最后的位置
	if(i< L->length){ 
		for(int k=i;k<L->length;k++)
			L->data[k-1]=L->data[k];
	}
	L->length--;
	return OK;
}
```

可以看出**，顺序表插入和删除的时间复杂度都是$O(n)$。而获取元素的时间复杂度只有$O(1)$**

​	通用的。下面是对于顺序表删除操作的规律：

​	**删除一个长度为n的顺序表第$i(0<=i<=n-1)$个元素时，需要向前移动==$n-i$==个元素**





#### 3.4.5 线性表顺序存储结构的优缺点

**优点：**

- 无序为表示表中元素之间的逻辑关系而增加额外的存储空间。
- 可以快速地存取表中任一位置的元素

**缺点：**

- 插入和删除操作需要移动大量元素
- 当线性表长度变化较大时，难以确定存储空间的容量。





#### 3.4.6 顺序表的完整程序

```java
//顺序表的实现
#include<stdio.h>
#include<stdlib.h>
#define OK 1
#define ERROR 0
#define MAXSIZE 5
#define FALSE 0
#define TRUE 1
typedef int Element; //顺序表的元素类型
typedef int Status; //函数的返回状态值
typedef struct {
	Element data[MAXSIZE]; //固定顺序表数组大小
	int length;
}List;

//顺序表初始化
Status iniList(List *L){
	L->length=0;
	return OK;
}

//判断表是否为空
Status ListEmpty(List L){
	if(L.length==0)
		return TRUE;
	else
		return FALSE;
}

//清空列表
Status ClearList(List *L){
	L->length=0;
	return OK;
}


//获取第i个值
Status getElem(List L,int i,Element *e){
	if(L.length<i ||L.length==0){
		printf("索引i值超过表长度或表长度为0");
		return ERROR;
	}
	
	*e =L.data[i-1];
	return OK;
}

//在列表中查找与e值相等的元素，返回该元素的序号
int LocateElem(List L,Element e){
	for(int i=0;i<L.length;i++){
		if(L.data[i]==e)
			return i+1;
	}
	
	return 0;
}

//插入元素操作
Status ListInsert(List*L, int i,Element e){
	//插入的位置不合理
	if(i>L->length+1|| i<1)
		return ERROR;
	
	//表满返回错误
	if(L->length ==MAXSIZE)
		return ERROR;
		//让表最后一个元素与前一个元素做交换，一直循环到i值
		//k值，表尾的索引
		for(int k=L->length;k>=i;k--){
			L->data[k] = L->data[k-1];
		}
	
	L->data[i-1] = e;
	L->length++;
	return OK;
}
//删除元素操作
Status ListDeleter(List*L,int i, Element *e){
	if(L->length==0)
		return ERROR;
	if(i>L->length ||i<1){
		return ERROR;
	}
	//先获取元素
	*e = L->data[i-1];
	
	//删除表中元素逻辑
	/*
	1.让i = i+1;即可，循环值结尾
	*/
	for(int j=i-1; j<L->length-1;j++){
		L->data[j]=L->data[j+1];
	}
	L->length--;
	return OK;
}

//显示表中的所有元素
void showList(List L){
	if(L.length==0){
		printf("顺序表中没有元素\n");
		return;
	}
	
	printf("[");
	for(int i=0;i<L.length; i++){
		printf("%d",L.data[i]);
		if(i<L.length-1)
			printf(",");
	}
	printf("]\n");
}
void showMenu(){
	printf("-----顺序表操作-----\n");
	printf("1.插入元素\t 2.删除元素\n");
	printf("3.查找元素\t 4.获取元素\n");
	printf("5.清空\t 	6.显示表元素\n");
	
}


int main(){
	//创建一个顺序表
	List list;
	iniList(&list); //初始化顺序表
	showMenu();
	int flag;
	printf("请选择你要进行的操作（输入0退出)\n");
	scanf("%d",&flag);
	while(flag){
		switch (flag) {
		case 1:{
			int index=0;
			int element=0;
			printf("请输入你要插入的位置和元素:\n");
			scanf("%d %d",&index,&element);
			if( ListInsert(&list,index,element)==OK){
				printf("插入成功\n");
			}else{
				printf("插入失败\n");
			}
			break;
		}
		case 2:{
			int index=0;
			Element e=0;
			printf("请输入你要删除的元素位置:\n");
			scanf("%d",&index);
			if( ListDeleter(&list,index,&e)==OK ){
				printf("删除成功，被删除的元素为%d\n",e);
			}else{
				printf("删除失败");
			}
			printf("删除元素\n");
			break;
		}
		case 3:{
			int e = 0;
			printf("请输入你要在表中查找的元素：\n");
			scanf("%d",&e);
			int flag = LocateElem(list,e);
			if(flag)
				printf("该元素位于表中第%d个位置\n",flag);
			else{
				printf("没有从该表中找到该元素\n");
			}
			break;
		}
		case 4:{
			int index =0;
			Element e=0;
			printf("请你输入要获取的元素位置：\n");
			scanf("%d",&index);
			getElem(list,index,&e);
			printf("您获取的元素是%d\n",e);
			break;
		}
		case 5:{
			ClearList(&list);
			printf("已清空该表\n");
			break;
		}
		case 6:{
			showList(list);
			break;
		}
		
		default:
			printf("无效指令\n");
			break;
		}
		
		showMenu();
		printf("请选择你要进行的操作（输入0退出）\n");
		scanf("%d",&flag);
	}
	
}
```









## 3.5 线性表的链式存储结构

线性表的链式存储结构，简称链表。顺序表最大的缺点就是插入和删除时需要移动大量的元素。而链表解决了这个问题。下面我们来讨论链表的具体思路



#### 3.5.1 链表结构定义

​	链表的每个数据域中，都含有下一个数据域的地址数据。这样一来，我们可以在第一个数据域中知道第二个数据域的位置，又能通过第二个数据域知道第三个数据域的位置，以此类推。链表的存储位置不是顺序的，是通过指针链接在一起的。

​	**把存储数据元素信息的域称为数据域，而存储直接后继位置的域称为指针域。指针域中存储的信息称作指针和链。**这两部分信息结合起来统称结点。n个结点链结成一个链表，即为线性表的链式存储结构。

​	==**链表中第一个节点的存储位置叫做头指针**==。我们规定，线性链表的最后一个结点指针为空（null）。有时，**为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。**头结点一般不存储数据域信息，可以存储线性表的长度等附加信息，但头结点不能计入链表长度值。

​	

#### 3.5.2 链表存储代码结构描述

若线性表为空，则头结点的指针域为空。

下面是用C语言描述的链表结构：

```c
//带头结点的单链表
typedef int Datatype;	
typedef struct Node{
	Datatype data; //存储数据
	struct Node * next; //指针域
}Node;
//当函数要让外部的指针变量（比如头指针）指向新的节点时，就必须传地址，也就是双重指针。
typedef Node* LinkList; //头指针,指向头结点单链表入口
```

​	`typedef struct Node *Linklist`为结点指针创建别名，`LinkList`是`struct Node*`的别名。`LinkList L`等价于`struct  Node *L`或`Node *L`。一般用LinkList L表明L是链表的头指针，==**头指针是链表的入口，想要访问链表就必须通过头指针。**==

​	假设我们设置了一个头结点。那么此时，头指针`*LinkList`应该指向头结点，头结点在指向第一个结点。以此类推。

```text
头指针 L
  │
  ▼
┌───────┐    ┌───────┐    ┌───────┐
│头结点 │───▶│节点1  │───▶│节点2  │───▶NULL
└───────┘    └───────┘    └───────┘

头指针变量 (LinkList L)           头结点 (实际内存块)
      │                          ┌───────────┐
      │                          │ 数据域    │ ← 通常为空或辅助信息
      └─────────────────────────▶│ 指针域    │───→ 首元结点(第一个数据元素)
                                 └───────────┘
```

​	注意，**头指针是一个指针，它用于指向头结点或首元结点。我们通过访问头指针来访问整个表，所以使用头指针来代表整个表**。在附设头结点的链表里，头指针指向头结点。而在没有附设头结点的链表里。头指针直接指向链表第一个元素

```txt
头指针 L
  │
  ▼
┌───────┐    ┌───────┐
│节点1  │───▶│节点2  │───▶NULL
└───────┘    └───────┘
```

​	**附设头结点的好处**：

1. **便于首元结点的处理**

   首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无须进行特殊处理；

2. **便于空表和非空表的统一处理**

   无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。





#### 3.5.3 为什么修改链表需要双重指针

​	先讨论指针的基础知识。指针是存储地址的变量，且C语言的函数是值传递的。看下面的函数和调用

```c
void swap(int a,int b){
	int temp= a;
	a=b;
	b=temp
}

int main(){
    int a=10;
    int b=20;
    swap(a,b);
}
```

​	什么是值传递，函数swap(a,b)获取变量a和变量b的值，赋值给形参。形式参数在函数里面做交换操作。但是在函数运行结束后，这两个形参就会释放掉。所以这个函数根本没有起到把a和b的值交换的作用。

​	但是，我们可以通过地址去操作或修改上面的值。每一个变量都有一个地址。看下面的程序

```c
void swap(int *a,int *b){
	int temp= *a;
	*a=*b;
	*b=temp
}

int main(){
    int a=10;
    int b=20;
    swap(&a,&b);
}
```

​	现在函数的形式参数变成了指针，但值传递没有变，不过传递的值从整型变成了地址值。实际上，该函数通过两个形式参数int指针指向了`a`和`b`的地址。然后该函数在通过解引用获取该地址上的值并修改。从而把交换作用到了实际参数上。

​	前面说过，传递的值只是从整型变成了地址值。如果我们试着修改地址值。会对实际参数起作用吗。

```c

void change(int * t){
	int temp = 100;
	t = &temp; //把地址修改为临时变量的地址
}
int main(){
	
	int a=10;
	int *p = &a;
	change(p);
	printf("%d",*p);
}
//输出10
```

​	从结果来看，修改地址值的操作并不能对实际参数起影响。那么要如何在函数里修改指针指向另一个地址呢？我们注意到，**要修改实际参数的值，就必须传入它的地址，通过解引用地址获取上面的值取修改。**

​	我们要修改整型变量的值，就必须传入整型变量的地址。

​	**同样的，我们要修改指针的值，就必须传入指针的地址。**是的，这可能有点绕，指针的值是地址，同样指针本身也是有地址的，任何一个变量都有地址。

​	那么，要在一个函数里让指针指向另一个地址，要传入的就是指向指针的指针。双重指针。比如：

```c
void change(int ** t){
	int temp = 100;
	*t = &temp;
}
int main(){
	
	int a=10;
	int *p = &a;
	change(&p);
	printf("%d",*p);
}
//输出100
```

​	这个程序成功的让指针指向另一个地址。让我来解析一遍。

1. t是双重指针，它的值是**实际参数指针p的地址**。

2. \*t为解引用，意为获取地址上的值。其实就是获取指针p上面的值

3. 而指针p又指向变量a的地址。

4. \*t =&temp，代表指针p指向临时变量的地址。

   这个程序只是为了方便理解双重指针，我们要知道函数结束后，里面的变量都会被回收。这是未定义行为，我们不知道被回收后的地址是否还能使用。

为了安全应该使用malloc专门管理内存，该函数分配的内存不会被自动回收，而是由程序员手动管理

```c
void change(int **t){
    *t = malloc(sizeof(int));
    **t = 100;
}
```



​	我们回到链表的结构中，讨论为什么修改链表要双重指针。

```c
typedef struct Node{
    ElemType data; //数据域
    struct Node *next; //指针域，指向下一个元素
}Node;
// typedef struct Node{...} Node； 使用此声明后，后续可以直接用Node类型名声明，而不用struct Node声明
typedef struct Node* LinkList; //现在LinkList是一个指向Node类型的指针
```

​	或是

```c
typedef struct Node{
    ElemType data; //数据域
    struct Node *next; //指针域，指向下一个元素
}Node;

typedef  Node* LinkList;
```

​	该结构使用`data`存储数据，`struct Node * next`表示指向下一个结点的地址。且封装了该结点指针为`LinkList`，它与`struct Node *`等价。

​	我们再来看这样一个函数：

```c
Status InitList(LinkList *L){   //初始化链表
	/*
	malloc函数返回void *指针，对他进行类型转换（LinkList)
	参数是字节大小。使用sizeof运算符计算结点的大小。
	从而成功为Linklist分配了空间
	*/
	*L = (LinkList)malloc(sizeof(Node)); 
	/*如果分配内存失败*/
	if(*L ==NULL){ //or !(*L)
		return ERROR;
    }
	(*L)->next =NULL;
	
	return OK;
}
```

​	显然，参数是一个双重指针，它表示需要一个**结点指针的地址**。注意，**因为它需要修改这个结点指针的值**，作用到实际参数上，所以它需要一个结点指针（或是头指针）的地址。

```c
*L = (LinkList)malloc(sizeof(Node));
```

​	`*L`解引用，代表头指针也就是`LinkList L`，给它分配内存空间，`(LinkList)`表示它需要转换为`Node*`指针。`malloc(sizeof(Node))`表示它需要一个结点大小的内存。这条程序给头指针分配了内存空间。这是正确的。

​	当我们想要修改头指针时，应该把双重指针l给解引用。`(*L)`；











## 3.6 链表的操作

同样的，链表的操作和顺序表的操作类似，初始化，增删改查等等。在这里，我们基于附设头结点来讨论操作。

#### 3.6.1 链表基础操作

基础操作包括：**初始化、是否为空表。返回表长**等等。

注意：单链表是由表头唯一确定，因此单链表可以用头指针的名字来命令，若头指针名是L，则把链表称为表L

```c
typedef int Datatype;	
typedef struct Node{
	Datatype data; //存储数据
	struct Node * next; //指针域
}Node;
void InitList(LinkList *L){
	*L = (LinkList)malloc(sizeof(Node));
	(*L)->next = NULL;
}

//判断链表是否为空
bool ListEmpty(LinkList L){
	return L->next==NULL;
	
}

//获取链表长度
int ListLength(LinkList L){
	int length=0;
	
	LinkList first = L->next;
	while(first){
		length++;
		first = first->next;
	}
	
	return length;
}

//清空链表元素，保留头结点
void ClearList(LinkList *L){
	LinkList head = (*L)->next ;//获取首元结点
	
	while(head){
		LinkList temp =head->next;
		free(head);
		head=temp;
	}
	
	(*L)->next =NULL;
}
```



#### 3.6.2 单链表的读取

​	在线性表的顺序存储结构中。要获取某个位置的元素是很容易的。但在单链表中，想要获取第i个元素就没那么容易。由于第i个元没办法一开始就知道在哪，必须从头开始找。

​	获取链表第i个数据的算法思路：

1. 声明一个指针p指向链表第一个结点，初始化j从1开始。
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累计1；
3. 若到链表末尾p为空，则说明第i个结点不存在。
4. 否则查找成功，返回结点p的数据

实现代码算法如下：

```java
//获取第i个位置的元素， i从1开始
Datatype GetElem(LinkList L,int i, Datatype *e){
	int j=1;
	
	
	LinkList head= L->next; //获取首元结点
	if(!head|| i<1){
		return -1; //空表或i值小于1
	}
	while(j<i&&head){
		head =head->next;
		j++;
	}
	//遍历完链表全部元素了，此时head为空，代表表中没有第i个位置的元素
	if(!head){
		return -1;
	}
	*e = head->data;
	return *e;
}
```



#### 3.6.3 单链表的插入

假设要插入的元素e的结点为s。只需将结点s插入到结点p和p->next之间即可。代码如下：

```java
s->next = p->next;
p->next = s;
```

现在，p->next指向的结点是s。而s->next指向的是原来p->next的地址。实现了插入操作。

```mermaid
flowchart LR
	结点P --> 结点S --> id["p->next"]
	
```

**单链表第i个数据插入结点的算法思路：**

1. 声明指针p指向链表头结点，初始化j从1开始。
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；
3. 若到链表末尾p为空，则说明第i个结点不存在；
4. 否则查找成功，在系统中生成一个空结点s；
5. 将数据元素e赋值给s->data; 
6. 单链表的插入标准语句 s->next = p->next；p->next =s;
7. 返回成功

实现代码算法如下：

```java
//插入元素,1<=i<=length+1
void InsertList(LinkList L,int i,Datatype x){
	int length = ListLength(L);
	if(i<1 || i>length+1)
		return;
	
	LinkList head =L; //头结点
	
	//假如插入位置为5，那么就要让first指针指向第4个结点,即循环i-1遍
	int j=0;
	while(head && j<i-1){
		j++;
		head = head->next;
	}
	
	//建立新结点
	LinkList newNode = (LinkList)malloc(sizeof(Node));
	newNode->data = x;
	newNode->next = head->next;
	head->next = newNode;
}

```

问题一：为什么要在函数内新定义一个LinkList（即指向struct Node的指针）变量p指向传入进来的*L；

答：假设不这样做，直接对L进行操作`*L = （*L)->next`,那么我们会丢失头指针，从而无法访问链表的后续元素。所以我们让p同样指向L，让p来一步步对链表的地址进行某种操作，比如修改，访问，插入操作。又不会影响原来的指针L，还是指向链表的第一位元素。**头指针是不会变动的（指向其他元素），头指针需要保证一直指向链表的第一个结点**



> ​	下面我们来分析这个代码具体思路以及为什么这样做：

1. 变量`j`用于计数，让它从1开始。
2. `LinkList p,s;`，p指向*L，从而对链表进行操作，而s是将要存储的结点
3. 重点分析这个循环，这个循环的目的是为了找到第`i-1`个结点，然后进行插入操作。**比如我要插入的位置是5，那么我就要找到第4个结点。通过第4个结点的指针域能知道第5个结点的位置**，从而进行典型的插入操作s->next = p->next；p->next =s;
4. 而后面的if语句是预防两种情况
   1. 循环结束后p为空值，代表遍历完了这个表，都没有让`j==i`，即这个表中没有第`i`个元素，比如表长为20，如果你要插入的位置是30，就会出现这种情况
   2. `j>i`是因为用户可能传入错误的值，比如传入0或负数，这是不被允许的，这里的函数参数i指的是要在表中第几个位置插入，所以i的值必须大于等于1
5. 为s结点分配内存。s是一个指向`struct Node`的指针，而`malloc`会返回`void *`指针，将它转换为`LinkList`。大小为`sizeof(Node)`。
6. 先把数据赋给s的数据域，再进行插入操作，把第i-1个结点的指针域赋值给s的指针域，让s指向i-1个结点的后继元素。然后让i-1结点的指针域指向s，插入操作就完成了。返回OK;





#### 3.6.4 单链表的删除

设要被删除的结点是q，只需让它的前继结点直接指向它的后继结点即可。我们把要被删除的结点q的前继结点叫做p。要做的就是一部，p->next = p->next->next。用q来代替next即是

```java
 q = p->next;
 p->next = q->next; /*将q的后继直接赋给p的后继*/
```

单链表第i个数据删除结点的算法思路：

1. 声明一指针p指向链表头指针，初始化j从1开始；
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
3. 若到链表末尾p为空，则说明第i个结点不存在；
4. 否则查找成功，将欲删除的结点p->next赋值给q；
5. 单链表的删除标准语句p->next = q->next；
6. 将q结点中的数据赋值给e，作为返回；
7. 释放q结点；
8. 返回成功；

实现代码算法如下：

```java
//删除元素，1<=i<=length
void DeleteList(LinkList L,int i,Datatype *e){
	int length = ListLength(L);
	if(i<1 || i >length)
		return;
	
	int j=0;
	LinkList head = L;
	while(head && j<i-1){
		head=head->next;
		j++;
	}
	
	LinkList temp = head->next ;//要被删除的元素
	head->next = temp->next ; //越过被删除的元素
	*e = temp->data;
	free(temp);

}
```

删除操作的算法思路和插入操作的算法思路很像，同样的通过第i个结点的前继结点进行操作。只不过操作的内容不同。下面是具体思路细节：

1. 同样让j从1开始
2. 声明`LinkList q,p;`，q用于找到第i个元素的前置结点，p用于存储第i个结点。
3. 让p指向头指针。从而能对链表进行操作
4. 插入与删除循环执行的内容都是一样的，区别在于执行条件，它们为什么不一样。先看删除操作的思路，假设我们要删除第i个结点。这个结点叫q，把q的前置结点称为p。那么我只需要进行一步操作，将前置结点p的指针域指向欲要删除结点q的指针域即可：

```java
p->next = q->next;
```

​	那么同样都是要找到第i个的前置结点，也就是i-1个节点。为什么这个循环的条件是`(p->next)`呢，因为按照正常预期，没有出差错，**循环结束时，`p->next`指向的结点就是我们要删除的结点**。如果这个节点为null，那么删除操作就变得没有意义，这也是为什么后面判断`(！p->next)`的原因。

​	

#### 3.6.5 单链表的销毁

从头指针开始，依次释放所有节点

```java
/* 单链表的销毁*/
/* 算法思路：从头指针开始，依次释放所有节点*/
Status DestoryList(LinkList *L){
	LinkList p;
	while(L){
		p=*L;
		*L=(*L)->next;
		free(p);
	}
	return OK;
}
```



#### 3.5.6 单链表的清空

```java
//清空链表元素，保留头结点
void ClearList(LinkList *L){
	LinkList head = (*L)->next ;//获取首元结点
	
	while(head){
		LinkList temp =head->next;
		free(head);
		head=temp;
	}
	
	(*L)->next =NULL;
}
```



#### 3.5.7 单链表的查找

按值查找——根据指定数据获取该数据所在的位置（地址或序号）

```java
int LocateElem(LinkList L,Datatype e){
	LinkList head = L->next;
	//检查是否为空表
	if(!head){
		return -1;
	}
	int j=1;
	while(head){
		if(head->data==e)
			return j;
		head =head->next;
		j++;
	}
		return -1;
}
```



#### 3.5.8 单链表整表创建

```java
//头插法初始化表，n表示元素个数
void CreateHeadList(LinkList *L,int n){
	//即不停的往第一个位置插入元素
	(*L) =(LinkList)malloc(sizeof(Node)); //创建头结点
	(*L)->next =NULL; 
	//设置随机数种子
	srand(time(0));
	
	for(int i=0;i<n;i++){
		int x = rand()%100+1; //设置随机数
		//创建新结点
		LinkList newNode = (LinkList)malloc(sizeof(Node));
		newNode->data =x;
		newNode->next = (*L)->next;
		(*L)->next = newNode;
	}
}


//尾插法初始化表
void CreateListTail(LinkList *L,int n){
	//不停的在最后一个位置插入元素
	(*L) =(LinkList)malloc(sizeof(Node)); //创建头结点
	(*L)->next =NULL; 
	//设置随机数种子
	srand(time(0));
	
	//定义一个新指针,去移动，不移动原本的头指针
	LinkList r = *L;
	for(int i=0;i<n;i++){
		int x = rand()%100+1; //设置随机数
		//创建新结点
		LinkList newNode = (LinkList)malloc(sizeof(Node));
		newNode->data = x;
		newNode->next =NULL;
		r->next = newNode;
		r=newNode;
	}
}
```

若线性表需要频繁查找，很少进行插入和删除操作时，选择顺序表更好。反之，选择链表



#### 3.6.9 单链表的完整程序

``` c
#include "LinkList.h"
//初始化链表
//LinkLst L 等价于 Node *L
void InitList(LinkList *L){
	*L = (LinkList)malloc(sizeof(Node));
	(*L)->next = NULL;
}

//判断链表是否为空
bool ListEmpty(LinkList L){
	return L->next==NULL;
	
}

//获取链表长度
int ListLength(LinkList L){
	int length=0;
	
	LinkList first = L->next;
	while(first){
		length++;
		first = first->next;
	}
	
	return length;
}

//清空链表元素，保留头结点
void ClearList(LinkList *L){
	LinkList head = (*L)->next ;//获取首元结点
	
	while(head){
		LinkList temp =head->next;
		free(head);
		head=temp;
	}
	
	(*L)->next =NULL;
}

//获取第i个位置的元素
Datatype GetElem(LinkList L,int i, Datatype *e){
	int j=1;
	
	
	LinkList head= L->next; //获取首元结点
	if(!head|| i<1){
		return -1; //空表或i值小于1
	}
	while(j<i&&head){
		head =head->next;
		j++;
	}
	//遍历完链表全部元素了，此时head为空，代表表中没有第i个位置的元素
	if(!head){
		return -1;
	}
	*e = head->data;
	return *e;
}

//查找元素e在表中的位置，查找成功返回下标(从1开始），否则返回-1表示查找失败
int LocateElem(LinkList L,Datatype e){
	LinkList head = L->next;
	//检查是否为空表
	if(!head){
		return -1;
	}
	int j=1;
	while(head){
		if(head->data==e)
			return j;
		head =head->next;
		j++;
	}
		return -1;
}

//插入元素,1<=i<=length+1
void InsertList(LinkList L,int i,Datatype x){
	int length = ListLength(L);
	if(i<1 || i>length+1)
		return;
	
	LinkList head =L; //头结点
	
	//假如插入位置为5，那么就要让first指针指向第4个结点,即循环i-1遍
	int j=0;
	while(head && j<i-1){
		j++;
		head = head->next;
	}
	
	//建立新结点
	LinkList newNode = (LinkList)malloc(sizeof(Node));
	newNode->data = x;
	newNode->next = head->next;
	head->next = newNode;
}

//删除元素，1<=i<=length
void DeleteList(LinkList L,int i,Datatype *e){
	int length = ListLength(L);
	if(i<1 || i >length)
		return;
	
	int j=0;
	LinkList head = L;
	while(head && j<i-1){
		head=head->next;
		j++;
	}
	
	LinkList temp = head->next ;//要被删除的元素
	head->next = temp->next ; //越过被删除的元素
	*e = temp->data;
	free(temp);

}

//查看表元素
void showList(LinkList L){
	if(ListEmpty(L))
	{
		printf("[]\n");
		return;
	}
	LinkList head = L->next;
	printf("[");
	while(head){
		printf("%d",head->data);
		if(head->next){
			printf(",");
		}
		head = head->next;
	}
	printf("]\n");
}


//头插法初始化表，n表示元素个数
void CreateHeadList(LinkList *L,int n){
	//即不停的往第一个位置插入元素
	(*L) =(LinkList)malloc(sizeof(Node)); //创建头结点
	(*L)->next =NULL; 
	//设置随机数种子
	srand(time(0));
	
	for(int i=0;i<n;i++){
		int x = rand()%100+1; //设置随机数
		//创建新结点
		LinkList newNode = (LinkList)malloc(sizeof(Node));
		newNode->data =x;
		newNode->next = (*L)->next;
		(*L)->next = newNode;
	}
}


//尾插法初始化表
void CreateListTail(LinkList *L,int n){
	//不停的在最后一个位置插入元素
	(*L) =(LinkList)malloc(sizeof(Node)); //创建头结点
	(*L)->next =NULL; 
	//设置随机数种子
	srand(time(0));
	
	//定义一个新指针,去移动，不移动原本的头指针
	LinkList r = *L;
	for(int i=0;i<n;i++){
		int x = rand()%100+1; //设置随机数
		//创建新结点
		LinkList newNode = (LinkList)malloc(sizeof(Node));
		newNode->data = x;
		newNode->next =NULL;
		r->next = newNode;
		r=newNode;
	}
}
```







## 3.7 循环链表

​	循环链表的实现很简单，**只需要将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成了一个环**，这种头尾相接的单链表称为单循环链表，简称循环链表。==从表中任一结点出发均可找到表中其他结点==。

​	注意，由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p->next是否为空，而是判断它们是否等于头指针。

```java
while( p!=L || p->next !=L){
    ....
}
```

​	我们把循环链表的最后一个结点的指针域将指向头结点，这样的指针可以把它叫做尾指针（rear）。 这样做的好处是，当我想要找a1时，它的时间复杂度是O（1），而且两个表的合并也方便。

​	假设有一个表A，它的尾指针是rearA，它的头结点是rearA->next。

​		一个表B，它的尾指针是rearB，它的头结点是rearB->next;

​	只需进行如下操作：

```java
p = rearA->next; // 保存a的头结点
rearA->next =rearB->next->next; //A的头结点指向B的首元结点

q = rearB->next; //保存b的头结点
rearB->next = p; //b的头结点指向a的头结点
free(q);
```

#### 3.7.1 循环链表的实现(无尾指针)

​	由于本人粗心，在结构定义中并没有维护尾指针。而是由头指针遍历获得尾指针。所以下面的实现并未体现出循环链表查找终端结点和两表连接时间复杂度为$O(1)$的特性，仅实现了循环的特性，即通过任意结点都可查找任意元素：

```java
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
//默认带头节点实现链表
#define OK 1
#define ERROR 0
#define FALSE 0
#define TRUE 1
typedef int Element; //顺序表的元素类型
typedef int Status; //函数的返回状态值

//循环链表结构
typedef struct CirNode{
	Element data;
	struct CirNode * next;
}CirNode,*CirList;

Status IniList(CirList *L){
	*L = (CirList)malloc(sizeof(CirNode));//创建头结点
	if(*L==NULL){
		return ERROR;
	}
	(*L)->next = *L; //让头结点指向自己，形成空表

	return OK;
}


//判断循环链表是否为空
Status ListEmpty(CirList L){
	if(L==NULL)
		return ERROR; //表不存在，返回错误
	
	if(L->next ==L ){
		return TRUE;
	}else
		return FALSE;
}


// 返回链表的长度
int ListLength(CirList L){
	if(L==NULL)
		return ERROR; //该表不存在
	
	CirList  p = L->next; //从首元结点开始遍历
	int length=0;
	while(p!=L){
		length++;
		p=p->next;
	}
	
	return length;
}
//清空该循环链表，但不清空头结点
Status ClearList(CirList *L){
	if(*L==NULL)
		return ERROR;
	CirList p = (*L)->next; //指针指向首元结点
	CirList temp;
	while (p!=*L){
		temp = p;
		p=p->next;
		free(temp);
	}
	(*L)->next = (*L);
	
	return OK;
}

//销毁链表：销毁后表不存在
Status DestoryList(CirList *L){
	if(*L==NULL)
		return OK;//链表已经不存在
	
	//先释放除了头结点以外的所有元素
	CirList p = (*L)->next; //指向首元结点
	CirList temp;
	while(p!=*L){
		temp = p->next;
		free(p);
		p=temp;
	}
	
	//再释放头结点
	free(*L);
	
	//将头指针置为空
	*L= NULL;
	
	return OK;
}

//对循环链表的插入
Status LintInsert( CirList *L ,int i, Element e){
	//检查链表是否存在和插入的位置是否合法
	if(*L== NULL || i<1){
		
	}
	CirList p = *L; //让尾指针指向头结点
	int j=0;

	//查找第i-1个结点：循环直达 j = i-1 或p->next指向头结点（表示已到链表尾部）
	while( p->next !=*L && j<i-1){
		p=p->next;
		j++;
	}
	
	if(j!=i-1){
		return ERROR;	
	}
	CirList s = (CirList)malloc(sizeof(CirNode));
	if(s ==NULL)
		return ERROR;
	s->data = e;
	s->next = p->next;
	p->next = s;
	return OK;
}

//对循环链表的删除
Status ListDelete(CirList *L,int i, Element *e){
	
	if(*L==NULL || i<1)	
		return ERROR;
	
	//创建尾指针指向头结点
	CirList p = *L;
	int j=0;
	//找到第i-1个结点
	while ( p->next !=*L && j<i-1){
		p=p->next;
		j++;
	}
	//当j==i-1时，就代表找到了第i-1个元素，反之没有
	if(j!=i-1){
		return ERROR;
	}
	
	*e = p->next->data;//获取该结点的数据
	CirList temp = p->next->next; //获取第i+1个结点
	free(p->next); //释放掉该结点的地址
	p->next = temp;
	return OK;
}

//获取循环链表第i个元素
Status GetElem(CirList L,int i, Element *e){
	//检查链表和获取位置是否合法
	if(L==NULL || i<1){
		return ERROR;
	}
	
	CirList p = L->next; //尾指针指向首元结点
	int j=1;
	while(p!=L && j<i){
		p=p->next;
		j++;
	}
	if(p==L ||j!=i){
		return ERROR;
	}
	*e= p->data;
	
	return OK;
}

//查找元素
int LocateElem(CirList L, Element e){
	if(L==NULL)
		return ERROR;
	
	CirList p= L->next;
	int index=1;
	while(p!=L){
		if(p->data == e){
			return index;
		}
		p=p->next;
		index++;
	}
	
	return 0;
}

//查看链表所有元素
void showList(CirList L){
	//检查该表是否存在
	if(L==NULL){
			printf("该表不存在\n");
		return;
	}
	if(ListEmpty(L)){
		printf("该表为空\n");
		return;
	}
		
	CirList p = L->next; //从首元结点开始遍历
	printf("[");
	while (p!=L){
		printf("%d",p->data);
		if(p->next!=L){
			printf(",");
		}
		p=p->next;
	}
	printf("]\n");
}

void showMenu(){
		printf("-----循环链表操作-----\n");
		printf("1.初始化\t 2.该表是否为空\n");
		printf("3.清空该表\t 4.获取元素\n");
		printf("5.查找元素\t 6.插入元素\n");
		printf("7.删除元素\t 8.查询表元素个数\n");
		printf("9.显示所有表元素\n10.销毁该表\n");	
}


int main(){
	CirList L;
	int flag;
	showMenu();
	printf("请选择你要做的操作：(按0结束)\n");
	scanf("%d",&flag);
	while(flag){
		switch (flag) {
		case 1:
			if(IniList(&L)){
				printf("初始化成功\n");
			}else{
				printf("初始化失败\n");
			}
			break;
		case 2:
			{
				if(ListEmpty(L))
					printf("该表为空\n");
				else{
					printf("该表不为空\n");
				}
				break;
			}
		
			case 3:{
				if(ClearList(&L))
					printf("该表已清空\n");
				else
					printf("操作失败\n");
				break;
			}
			case 4:{
				int index;
				Element e;
				printf("请输入你要获取元素的位置:\n");
				scanf("%d",&index);
				if(GetElem(L,index,&e)){
					printf("您获取的元素是%d\n",e);
				}else{
					printf("获取失败\n");
				}
				break;
				
			}
			case 5:{
				Element e;
				printf("请输入你要查找的元素：\n");
				scanf("%d",&e);
				int index = LocateElem(L,e);
				if(index){
					printf("查找成功,该元素位于%d\n",index);
				}else
					printf("查找失败，未在该表找到该元素\n");
				break;
			}
			case 6:{
				int index =0;
				Element e=0;
				printf("请输入你想要插入的位置和元素:\n");
				scanf("%d %d",&index,&e);
				if(LintInsert(&L,index,e)){
					printf("插入成功\n");
				}else{
					printf("插入失败\n");
				}
				break;
				
			}
			case 7:{
				int index =0;
				Element e=0;
				printf("请输入你要删除的位置:\n");
				scanf("%d",&index);
				if(ListDelete(&L,index,&e)){
					printf("删除成功，被删除的元素是%d\n",e);
				}else{
					printf("删除失败\n");
				}
				break;
			}
			case 8:{
				printf("该表有%d个元素\n",ListLength(L));
				break;
			}
			case 9:{
				showList(L);
				break;
			}
			case 10:{
				if(DestoryList(&L)){
					printf("该表已销毁\n");
				}else{
					printf("操作失败\n");
				}
				break;
			}
			default:
			printf("无效操作\n");
			break;
		}
		showMenu();
		printf("请选择你要做的操作：(按0结束)\n");
		scanf("%d",&flag);
	}
}

```

​	在许多操作上很单链表类似，差异在于终止条件和起始条件。



#### 3.7.2 尾指针实现循环链表

​	使用尾指针维护循环链表有很多优势，可以通过尾指针立即访问到最后一个结点。或者通过`rear->next`立即访问到第一个结点。因此，在带有尾指针的循环链表中，通常不单独定义头指针。而是用尾指针的next域来指向第一个元素。	

​	使用头结点和不使用头结点的区别。

| 特性          | 尾指针→首元结点              | 尾指针→头结点→首元结点 |
| :------------ | :--------------------------- | :--------------------- |
| 内存使用      | 更少（无头结点）             | 更多（有头结点）       |
| 空表表示      | `tail = NULL`                | `tail->next = header`  |
| 代码复杂度    | 稍高（需要处理更多边界条件） | 稍低（边界条件更统一） |
| 插入/删除操作 | 需要更多特殊情况处理         | 操作更一致             |
| 教学常用性    | 较少                         | 较多                   |

​	因此在大多的实际应用中，推荐使用尾指针直接指向最后一个结点，最后一个节点的next指向首元结点，

```java
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
//不带头结点且用尾指针维护该循环链表
#define OK 1
#define ERROR 0
#define FALSE 0
#define TRUE 1
typedef int Element; //顺序表的元素类型
typedef int Status; //函数的返回状态值

//循环链表结构定义
typedef struct CirNode {
	Element data;
	struct CirNode *next;
}CirNode;

//尾指针，指向最后一个结点，可看为表的入口
typedef CirNode *CirCularList; 

Status IniList(CirCularList *R){	
	*R=NULL; //，所以空表由于不使用头结点状态下尾指针为空
	return OK;
}

Status EmptyList(CirCularList R){
	if(R==NULL){
		return TRUE;
	}else
		return FALSE;
}

int ListLength(CirCularList R){
	if(R==NULL)
		return 0;
	CirCularList p = R->next; //获取首元结点
	
	int length=1; //先计算尾结点
	//这个循环会忽略掉尾结点元素，所以先把长度+1算上尾结点
	while(p!=R){
		p=p->next;
		length++;
	}
	return length;
}	

//清空表
Status ClearList(CirCularList *R){
	if(*R==NULL)
		return OK; //表本身已经清空
	
	CirCularList head = (*R)->next; //创建头指针
	while(head!=*R){
		CirCularList temp = head->next;
		free(head);
		head = temp;
	}
	free(*R); //手动释放尾指针
	*R=NULL; //将尾指针置空
	return OK;
}

//在任意位置插入元素， 插入的范围是 1~Length
Status InsertList(CirCularList *R,int i, Element e){
	//处理空链表的情况，在空链表的时候，插入位置只能是1
	if(*R==NULL){
		if(i!=1){
			return ERROR;
		}
		CirCularList s = malloc(sizeof(CirNode));
		if(s==NULL){
			return ERROR;
		}
		s->data=e;
		s->next =s;//指向自己，形成循环
		(*R)=s; //尾指针再指向第一个元素
		return OK;
	}
	
	
	//处理在第一个位置插入的情况,在处理头部结点时，体现了O(1)的时间复杂度
	if(i==1){
			CirCularList s =(CirCularList)malloc(sizeof(CirNode)); //新结点
			if(s==NULL)
				return ERROR;
			//进入这个判断的前提是表中有元素，即(*R)->next不是空的
			//直接开始交换
			s->data=e; //存入数据
			s->next = (*R)->next; //使新结点指向尾结点的next域，即第1个结点
			(*R)->next =s; //尾结点的next域再指向新结点，完成插入
			return OK;
	}
	
	
	//处理插入位置在表长位置+1的情况
	if(i==ListLength(*R)+1){
		CirCularList s = (CirCularList)malloc(sizeof(CirNode));
		s->data = e;
		s->next = (*R)->next;
		(*R)->next = s; //让尾结点的next域指向s
		(*R) =s;
		return OK;
	}
	
	
	//处理在第i个位置插入的情况
	CirCularList head = (*R)->next ;//头指针指向首元结点
	int j=1;
	
	//循环遍历，寻找第i-1个结点，假设i值是5，那么只需遍历3次就可以找到第4个结点
	while(head!=(*R) && j<i-1){
		head=head->next;
		j++;
	}
	
	//如果j!=i就代表 表中没有第i个元素
	if(j!=i-1|| i>ListLength(*R)+1){
		return ERROR;
	}
		
	//此时，head指向第i-1个结点。
	CirCularList s = (CirCularList)malloc(sizeof(CirNode)); //创建新结点
	if(s==NULL)
		return ERROR;
	
	s->data=e;
	s->next = head->next;
	head->next =s;
	
	return OK;
}

//在任意位置删除元素 , 1<=i<=Length
Status DeleteList(CirCularList *R,int i, Element *e){
	if(*R == NULL || i < 1) {
		return ERROR; // 空链表或无效位置
	}
	//处理删除第一个元素
	if(i==1){
		//当表中只有一个元素
		if((*R)->next == *R){
			*e= (*R)->data; //读取数据
			free(*R); //释放该结点
			*R=NULL;
			return OK;
		}else{
			//表中不止一个元素，但删除的位置是1
		
			CirCularList temp = (*R)->next; //保存第一个结点的位置
			*e= temp->data;
			CirCularList head = temp->next; //保存第2个结点的位置
			(*R)->next = head; //更新第一个元素的位置，使尾结点的next域指向第2个元素的位置
			free(temp);//释放第一个结点的内存
			return OK;
		}
	}
	
	
	//删除第i个结点
	//当i大于这个表长的时候，返回错误
	if(i>ListLength(*R))
	{
		return ERROR;
	}
	
	
	
	CirCularList head = (*R)->next; //创建头指针，指向首元结点
	//寻找第i-1个结点
	int j=1;
	
	while(head!=*R && j<i-1){
		head=head->next;
		j++;
	}
	
	if(j!=i-1)
		return ERROR;
	
	//当删除的结点是尾结点时
	if(head->next ==*R){
		/*
		删除分析，如果要删除的是尾结点，那么操作步骤是
		让尾结点的前一个元素指向尾结点的后一个元素，即首元结点。
		再将尾指针指向尾结点的前一个元素。在这里
		尾结点的前一个元素由循环找到：head指针
		head ： 尾结点的前一个元素
		(*R)->next: 首元结点
		*/
		*e = (*R)->data; //保存尾结点的数据
		CirCularList temp =  (*R)->next; //保存首元结点的位置
		free(*R); //释放尾结点
		head->next = temp;//让i-1个结点的指针域指向首元结点
		*R = head; //更新尾指针
		return OK;
	}
	/*
	删除分析：此时，head指向第i-1个元素，head->next是第i个元素
	那么head->next->next则是第i+1个元素，
	我们要让第i个元素的指针域指向第i+1个元素，
	所以首先存储第i+1个元素的位置
	*/
	CirCularList temp = head->next->next; //存储第i+1个元素的位置
	*e = head->next->data; //保留数据
	free(head->next);//释放第i个结点
	head->next = temp; //第i个元素的指针域指向第i+1个元素
	
	return OK;
}

//该函数在获取头部结点时时间复杂度为O(1),在处理其他结点时，时间复杂度为O(n)
Status GetElem(CirCularList R,int i, Element *e){
	if(R==NULL)
		return ERROR;
	//在处理头部结点时非常简单，时间复杂度尾O(1)
	if(i==1){
		*e=R->next->data;
		return OK;
	}
	
	//要遍历到第i个位置
	CirCularList head=R->next; //从第一个位置开始
	int j=1;
	while(head!=R && j<i){
		head=head->next;
		j++;
	}
	
	if(j!=i)
		return ERROR;
	*e=head->data;
	return OK;
}


//连接两表
Status LinkList(CirCularList *R1,CirCularList *R2){
	// 检查指针有效性
	if (R1 == NULL || R2 == NULL) {
		return ERROR;
	}
	
	// 如果表2为空，直接返回OK，因为连接后表1不变
	if (*R2 == NULL) {
		return OK;
	}
	
	// 如果表1为空，则连接后链表即为表2，更新R1指向R2的尾指针，并重置R2
	if (*R1 == NULL) {
		*R1 = *R2;
		*R2 = NULL;
		return OK;
	}
	
	/*
	让r1的尾指针指向r2的头指针
	r2的尾指针指向r1的头指针，
	*/
	
	//先临时存储r1的头指针
	CirCularList R1Head = (*R1)->next; 
	
	(*R1)->next = (*R2)->next; //R1的的尾结点指针域指向R2的头结点
	
	//临时存储R2的头结点（首元结点）
	(*R2)->next = R1Head;  //表2的尾结点的next域指向表1的头结点
	*R1 = (*R2); //更新尾指针
	*R2=NULL;
	return OK;
}

Status LocaleElem(CirCularList R, Element e){
	if(R==NULL)
		return ERROR;
	int index=1;
	CirCularList head =R->next;
	while(head!=R){
		if(head->data == e)
			return index;
		head=head->next;
		index++;
	}
	if(e==R->data){
		return index;
	}
	return 0;
}
void showList(CirCularList R){
	if(R==NULL){
		printf("该表不存在或为空\n");
		return;
	}
	if(R->next==R){
		printf("[%d]\n",R->data);
	}else{
		CirCularList head = R->next;
		printf("[");
		//由于这个循环不会输出尾指针上的结点数据
		while(head != R){
			printf("%d",head->data);
			if(head->next !=R){
				printf(",");
			}
			head = head->next;
		}
		//所以我们这里手动输出
		printf(",%d]\n",R->data);
	}

}

void showMenu(){
	printf("-----循环链表操作-----\n");
	printf("1.初始化\t 2.该表是否为空\n");
	printf("3.清空该表\t 4.获取元素\n");
	printf("5.查找元素\t 6.插入元素\n");
	printf("7.删除元素\t 8.查询表元素个数\n");
	printf("9.显示所有表元素\n10.在在尾部添加元素\n");
	printf("11.删除尾部元素\n12.连接两表\n");
	
}

/*
int main(){
	CirCularList R;
	int flag;
	showMenu();
	printf("请选择你要做的操作：(按0结束)\n");
	scanf("%d",&flag);
	while(flag){
		switch (flag) {
		case 1:{
			if(IniList(&R)){
				printf("初始化成功\n");
			}else
				printf("初始化失败\n");
		
			break;
		}
			
		case 2:{
			if(EmptyList(R))
				printf("该表为空\n");
			else
				printf("该表不为空\n");
			break;
		}
		case 3:{
			ClearList(&R);
			printf("表已清空\n");
			break;
		}
		case 4:{
			int index=0;
			printf("请输入你要获取元素所在的位置：\n");
			scanf("%d",&index);
			Element e;
			if(GetElem(R,index,&e)){
				printf("在第个位置上的元素为%d\n",e);
			}else
				printf("获取失败，该表中没有第%d个元素\n",index);
			break;
				
		}
		case 5:{
			int index;
			Element e;
			printf("请输入你要查找的元素:\n");
			scanf("%d",&e);
			index = LocaleElem(R,e);
			if(index){
				printf("查找成功，该元素位于表中%d处\n",index);
			}else
				printf("查找失败，表中没有元素\n");
			break;
		}
		case 6:{
			int index=0;
			Element e=0;
			printf("请输入你要插入的位置和元素\n");
			scanf("%d%d",&index,&e);
			if(InsertList(&R,index,e)){
				printf("插入成功\n");
			}else
				printf("插入失败\n");
			break;
				
		}
		case 7:{
			int index=0;
			Element e;
			printf("请输入你要删除的元素位置:\n");
			scanf("%d",&index);
			if(DeleteList(&R,index,&e)){
				printf("删除成功，被删除的元素是%d\n",e);
			}else{
				printf("删除失败\n");
			}
			break;
		}
		case 8:{
			int length = ListLength(R);
			if(length){
				printf("该表的元素个数为%d\n",length);
			}else
				printf("该表没有元素\n");
			break;
		}
		case 9:{
			showList(R);
			break;
		}
		default:{
			printf("无效操作\n");
		}
		}
		showMenu();
		printf("请选择你要做的操作：(按0结束)\n");
		scanf("%d",&flag);
	}
}
*/

int main(){
	CirCularList R1;
	IniList(&R1);
	CirCularList R2;
	IniList(&R2);
	InsertList(&R1,1,1);
	InsertList(&R1,2,3);
	InsertList(&R1,3,5);
	InsertList(&R1,4,7);
	showList(R1);
	InsertList(&R2,1,2);
	InsertList(&R2,2,4);
	InsertList(&R2,3,6);
	InsertList(&R2,4,8);
	showList(R2);
	LinkList(&R1,&R2);
	showList(R1);
}

```



#### 3.7.3循环链表连接两表

​	操作步骤：

1. 首先检查参数的合法型
2. 如果表1为空，则连接后链表即为表2，更新R1指向R2的尾指针，重置R2
3. 临时存储R1的首元结点
4. 让R1的尾结点指针域指向R2的首元结点
5. 让R2的尾结点指针域指向R1的首元结点
6. 更新尾指针，原先指向R1的尾结点，现在要指向R2的尾结点
7. 将R2尾指针置空

```java
//连接两表
Status LinkList(CirCularList *R1,CirCularList *R2){
	// 检查指针有效性
	if (R1 == NULL || R2 == NULL) {
		return ERROR;
	}
	
	// 如果表2为空，直接返回OK，因为连接后表1不变
	if (*R2 == NULL) {
		return OK;
	}
	
	// 如果表1为空，则连接后链表即为表2，更新R1指向R2的尾指针，并重置R2
	if (*R1 == NULL) {
		*R1 = *R2;
		*R2 = NULL;
		return OK;
	}
	
	/*
	让r1的尾指针指向r2的头指针
	r2的尾指针指向r1的头指针，
	*/
	
	//先临时存储r1的头指针
	CirCularList R1Head = (*R1)->next; 
	
	(*R1)->next = (*R2)->next; //R1的的尾结点指针域指向R2的头结点
	
	//临时存储R2的头结点（首元结点）
	(*R2)->next = R1Head;  //表2的尾结点的next域指向表1的头结点
	*R1 = (*R2); //更新尾指针
	*R2=NULL;
	return OK;
}
```





## 3.8 双向链表。

​	在单链表中，next指针使我们查找下一结点的时间复杂度为$O(1)$。但是要查找上一结点的时间复杂度就是$O(n)$。而双向链表克服了这一单向性的缺点。

​	双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。下面是它的存储结构

```java
typedef struct DulNode{
    ElemType data;
    struct DulNode *prior;  //直接前驱指针
    struct DulNode *next; //直接后继指针
} DulNode, *DoLinkList;
```

​	



#### 3.8.1 插入操作

​	本次实现使用的是带头结点的不循环双向链表。在初始化时，我们将给头结点分配内存空间，并且它的前驱后继指针置为空。我们在实现插入操作时，一般会注意几个地方：

1. 插入操作函数原型：`Status ListInsert(DoLinkList *L,int i, Element e)`;
2. 对于参数i的范围是: $1<=i<=length+1$, 第一步就要检查L指针是否指向了头结点，如果它是空指针，那么返回错误，

```java
if(*L==NULL || i<1){
    return ERROR;
}
```

​	此时完成了i值的负数和0检查，对于i值大于表长这件事不用担心。因为链表使用指针连接，当指针为空时，就代表了已经超过了表长范围。对于这个参数在下面做检查

3. 当我们想在第i个位置插入元素，那么就需要找到第i-1个元素的指针。下面是一般操作

```java
DuLinkList p = *L; //指向头结点
int j=0;  //同步下标，一般头结点代表第0个元素
while(p!=NULL || j<i-1){
    p=p->next;
    j++;
}
```

4. 这个循环结束后，只有两种情况
   1. p指向了第i-1个结点
   2. p指向NULL。

​	注意，不循环的双向链表的表尾条件同样是p\==NULL，所以，如果p\==NULL就代表已经走完了整个表，下面检查

```java
if(p==NULL){
    return ERROR;
}
```

5. 不同于单链表，不需要对表尾插入做检查。至于为什么，在下一点解释。：
   1. 初始化新结点内存以及数据；
   2. 新结点的`prior`域指向当前结点p（也就是第i-1个）结点
   3. 新结点的`next`域指向当前结点p的next域：`s->next = p->next`; 也就是使新结点的next域指向第i+1结点。当然，这一步是在表尾，p->next域为空。
   4. 当前结点p的next域指向新结点：`p->next = s`;
   5. 如果`p->next！=NULL`，则需要让第i+1个结点的前驱指针指向s：`p->next->prior=s`，反之不操作。因为p->next ==NULL时代表在尾部进行插入操作，比如表长为5，插入位置为6，此时，p指向第5个元素。而p->next为空指针，无法操作`p->next->prior = s`;
      1. 返回OK；

```java
//插入位置 1<=i<=Length+1
Status ListInsert(DoLinkList *L,int i, Element e){
	//头结点为空，返回ERROR
	if(*L==NULL || i<1){
		return ERROR;
	}
	
	DoLinkList p = *L; //让p指向头指针
	int j=0; //符合头节点是第0个节点的概念
	while(p!=NULL && j<i-1){
		p=p->next;
		j++;
	}
	//循环结束，现在p指向第i-1个元素
	if(p==NULL){
		//当p指针为空时，代表已经遍历完了整表
		return ERROR;
	}

	
	DoLinkList s = (DoLinkList)malloc(sizeof(DulNode));//为新结点分配内存
	s->data= e;
	s->prior = p; //将前驱指针指向第i-个元素;
	s->next = p->next; //将后继指针指向第i+1个元素
	//如果p不是最后一个节点，需要修改p->next节点的prior指针
	if(p->next!=NULL){
		p->next->prior = s; //将第i+1个元素的前驱指针指向新元素
	}

	p->next = s;
	
	return OK;
}
```



#### 3.8.2 删除操作

​	对于删除操作，其正常范围在1~Length，插入操作可以在表长+1位置中插入元素，也就是等同于在表尾添加操作。但删除最多只能删除表尾的元素。

​	下面是算法思路：

1. 检查头指针和范围
2. 定位要删除节点的前一个节点。
3. 验证位置有效性
4. 保存数据和节点指针
5. 调整链表指针连接
6. 释放内存并返回

```java
//删除操作，1<=i<=Length
Status ListDelete(DoLinkList *L ,int i ,Element *e){
	if(*L==NULL || i<1 || ListEmpty(*L))
		return ERROR;
	
	DoLinkList p = *L;
	int j=0;
	
	
	//循环结束后，指针指向第i-1个结点
	while(p!=NULL && j<i-1){
		p=p->next;
		j++;
	}
	
	
	//如果p为空或p->next为空，返回错误。
	if(p==NULL|| p->next==NULL)
		return ERROR;
	
	*e = p->next->data; //获取第i个结点的数据
	DoLinkList temp = p->next; //临时存储第i个结点的地址
	p->next = temp->next;//第i-1个结点next指针域指向第i+1个结点
	if(temp->next!=NULL){
		temp->next->prior = p; //第i+1个结点的prior域指向p
	}
	free(temp);
	return OK;
}
```





