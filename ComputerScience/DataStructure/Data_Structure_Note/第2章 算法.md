==算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作==



## 2.1 两种算法的比较

一般让你写一个求1+2+3+·····+100结果的程序，都是这样写：

```java
int i,sum=0;
for(i=1;i<=100;i++)
{
    sum=sum+i;
}
printf("%d",sum);
```

高斯求和则是这样：

```java
int sum=0, n =100;
sum = (1+n)*n/2; 
printf("%d",sum);
```

​	这种方法不仅可以用于1加到100，就是加到1千、1万、1亿，也就是瞬间的事。如果让第一个程序计算1千次，一万次，那很明显，第二个程序比第一个程序要快得多得多。





## 2.2 算法定义。

​	算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作



## 2.3 算法的特性

​	算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。



#### 2.3.1 输入输出

算法具有零个或多个输入。但算法至少有一个或多个输出。



#### 2.3.2 有穷性

指算法在执行有限的步骤之后，会自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。



#### 2.3.3 确定性

算法的每一步骤都具有确定的含义，不会出现二义性。



#### 2.3.4 可行性

算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。



## 2.4 算法设计的要求

算法设计有4个要求：

1. 正确性
2. 可读性
3. 健壮性
4. 时间效率高和存储量低





## 2.5算法时间复杂度

#### 2.5.1 算法时间复杂度定义

​	在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况确定T（n）的数量级。算法的时间复杂度，也就是算法时间量度，记坐T（n） = O（f（n））。它表示随问题规模n的增大，算法执行时间的增长率和f（n）的增至率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f（n）是问题规模n的某个函数。

​	这样用大写O（）来体现算法时间复杂度的记法，称之为大O记法。

​	一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。

​	**时间复杂度最重要的参数就是问题规模n（输入规模）。随着问题规模n的增长，语句总的执行次数T(n)也跟着增长，执行次数T（n）增长最慢的算法称为最优算法**。

#### 2.5.2 推导大O阶方法

推导大O阶：

1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且系数不是1，则去除这个项相乘的系数。得到的结果就是大O阶。





#### 2.5.3 常数阶

```java
int sum=0,n=100;  /*执行一次*/
sum = (1+100)*n/2;  /*执行一次*/
printf("%d",sum); /*执行一次*/
```

这个算法的运行次数函数是f(n) = 3; 根据推导大O阶算法：

第一步：将常数项3改为1。

第二部：保留最高项，该程序没有最高项。

所以，这个算法的时间复杂度为O（1）；

试想一下，将算法中的语句sum=(1+n)*n/2重复10，即

```java
int sum=0,n=100;  /*执行1次*/
sum = (1+100)*n/2;  /*执行1次*/
sum = (1+100)*n/2;  /*执行2次*/
sum = (1+100)*n/2;  /*执行3次*/
sum = (1+100)*n/2;  /*执行4次*/
sum = (1+100)*n/2;  /*执行5次*/
sum = (1+100)*n/2;  /*执行6次*/
sum = (1+100)*n/2;  /*执行7次*/
sum = (1+100)*n/2;  /*执行8次*/
sum = (1+100)*n/2;  /*执行9次*/
sum = (1+100)*n/2;  /*执行10次*/
printf("%d",sum); /*执行一次*/
```

​	事实上，无论n为多少，上面的两段代码就是3次和12次的差异。**这种与问题的大小（n的大小）无关**，执行时间恒定的算法，我们称之为具有O（1）的时间复杂度，又叫常数阶

​	**常数阶O（1）表示 ，算法的执行时间不随着问题规模n的变化而变化，无论输入数据量有多大，其运行时间都是固定的。换句话说，常数阶的运行次数于输入规模n无关。它不会因为输入规模n的增长，而导致运行次数T(n)的增长，其运行时间是恒定的**。

```c
for(int i=1;i<=10;i++){
    printf("%d",i); 
}
```

包括这个程序的时间复杂度也是O（1），因为这个程序里没有参数n，运行次数是固定。不随着n变化而变化，不管n是多少，它的执行次数永远的是10次。

注意：不管这个常数（T(n)）是多少，都记作O（1），而不能是O(3)、O(10)等其他数字。

对于分支结构而言，无论是真，还是假，执行次数都是恒定的，不会随着n的变大而发生变化。所有单纯的分支结构，其时间复杂的也是O（1）。



#### 2.5.4 线性阶

​	**线性阶的时间复杂度为O(n)，因为它随着输入规模n的变化而变化，这个变化率为1：1**。也就是n增长1，则运行次数T(n)增长1。换句话说，输入规模n是多少，该算法运行多少次

```java
for(int i=0;i<n;i++)
{
    printf("%d",i);
}
```



#### 2.5.5 对数阶

```java
int count =1;
while(count<n)
{
    count =count *2;
}
```

​	由于每次count乘以2之后，就距离n更近一份。也就是说，有多少个2相乘后大于n，则会退出循环。由$2^x=n$得到$x=log_2n$。这个循环的时间复杂度为O($logn$)



#### 2.5.6 平方阶

下面是一个嵌套循环，它的内循环刚刚已经分析过，内循环的时间复杂度为O（n）。

`````c
int i,j;
for(i=0;i<n;i++){
	for(j=0;j<n;j++){
		/*时间复杂度为O(1)的程序步骤*/
	}
}

`````

而对于外层的循环，不过是内部的这个时间复杂度为O（n）的语句，再循环n次。所以这段代码的时间复杂度为O（$n^2$）。

如果外循环的次数该为了m，时间复杂度就变为O（$m*n$)。

```java
int i,j;
for(i=0;i<m;i++){
	for(j=0;j<n;j++){
		/*时间复杂度为O(1)的程序步骤*/
	}
}

```

